Disassembly Listing for dspic33-servo-can-node
Generated From:
C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/dist/default/debug/dspic33-servo-can-node.X.debug.elf
Jun 17, 2015 11:24:21 AM

---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/wdt.c  ---------------------------
1:                 
2:                 ////////////////////////////////////////////////////////////////////////////////
3:                 ///
4:                 /// @file   $FILE$
5:                 /// @author $AUTHOR$
6:                 /// @date   $DATE$
7:                 /// @brief  Source code file for defining hardware operation.   
8:                 ///
9:                 ////////////////////////////////////////////////////////////////////////////////
10:                
11:                // *****************************************************************************
12:                // ************************** System Include Files *****************************
13:                // *****************************************************************************
14:                #include <xc.h>
15:                #include <stdbool.h>
16:                #include <stddef.h>
17:                #include <stdint.h>
18:                
19:                // *****************************************************************************
20:                // ************************** User Include Files *******************************
21:                // *****************************************************************************
22:                #include "wdt.h"
23:                
24:                // *****************************************************************************
25:                // ************************** Defines ******************************************
26:                // *****************************************************************************
27:                
28:                // *****************************************************************************
29:                // ************************** Global Variable Definitions **********************
30:                // *****************************************************************************
31:                
32:                // *****************************************************************************
33:                // ************************** File-Scope Variable Definitions ******************
34:                // *****************************************************************************
35:                
36:                // *****************************************************************************
37:                // ************************** Function Prototypes ******************************
38:                // *****************************************************************************
39:                
40:                // *****************************************************************************
41:                // ************************** Global Functions *********************************
42:                // *****************************************************************************
43:                void WDTService ( void )
44:                {
0020B2  FA0000     LNK #0x0
45:                    // Clear the watchdog timer values.
46:                    //
47:                    // Note: Hardware specific function (see 'xc.h') defined for clearing
48:                    // the watchdog timer values.
49:                    ClrWdt();
0020B4  FE6000     CLRWDT
50:                }
0020B6  FA8000     ULNK
0020B8  060000     RETURN
51:                
52:                void WDTEnable ( void )
53:                {
0020BA  FA0000     LNK #0x0
54:                    // Enable watchdog timer operation.
55:                    //
56:                    // Note: enabling of the watchdog timer causes a reset of the counter
57:                    // value.
58:                    //    
59:                    // RCONbits.SWDTEN = 1;                                                     DEBUG: TEMPORARILY DISABLED
60:                }
0020BC  FA8000     ULNK
0020BE  060000     RETURN
61:                
62:                void WDTDisable ( void )
63:                {
0020C0  FA0000     LNK #0x0
64:                    // Disable watchdog timer operation.
65:                    RCONbits.SWDTEN = 0;    
0020C2  A9A740     BCLR RCON, #5
66:                }
0020C4  FA8000     ULNK
0020C6  060000     RETURN
67:                
68:                // *****************************************************************************
69:                // ************************** Static Functions *********************************
70:                // *****************************************************************************
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/vsense.c  ------------------------
1:                 ////////////////////////////////////////////////////////////////////////////////
2:                 ///
3:                 /// @file   $FILE$
4:                 /// @author $AUTHOR$
5:                 /// @date   $DATE$
6:                 /// @brief  Source code file for defining hardware operation.   
7:                 ///
8:                 ////////////////////////////////////////////////////////////////////////////////
9:                 
10:                // *****************************************************************************
11:                // ************************** System Include Files *****************************
12:                // *****************************************************************************
13:                #include <xc.h>
14:                #include <stdbool.h>
15:                #include <stddef.h>
16:                #include <stdint.h>
17:                
18:                // *****************************************************************************
19:                // ************************** User Include Files *******************************
20:                // *****************************************************************************
21:                #include "vsense.h"
22:                #include "adc.h"
23:                #include "can.h"
24:                #include "cfg.h"
25:                #include "util.h"
26:                
27:                // *****************************************************************************
28:                // ************************** Defines ******************************************
29:                // *****************************************************************************
30:                
31:                // *****************************************************************************
32:                // ************************** Global Variable Definitions **********************
33:                // *****************************************************************************
34:                
35:                // *****************************************************************************
36:                // ************************** File-Scope Variable Definitions ******************
37:                // *****************************************************************************
38:                
39:                // *****************************************************************************
40:                // ************************** Function Prototypes ******************************
41:                // *****************************************************************************
42:                
43:                // *****************************************************************************
44:                // ************************** Global Functions *********************************
45:                // *****************************************************************************
46:                void VsenseService( void )
47:                {
000FB0  FA0040     LNK #0x40
48:                    CAN_TX_VSENSE_DATA_U vsense_msg;
49:                    
50:                    uint16_t vsense1_raw;
51:                    int16_t  vsense1_cor;
52:                    int32_t  vsense1_coeff[ CFG_VSENSE1_COEFF_LEN ];
53:                    
54:                    uint16_t vsense2_raw;
55:                    int16_t  vsense2_cor;
56:                    int32_t  vsense2_coeff[ CFG_VSENSE2_COEFF_LEN ];
57:                    
58:                    // Get vsense signal raw values.
59:                    vsense1_raw = ADCGet( ADC_AIN2 );
000FB2  EB0000     CLR W0
000FB4  07065F     RCALL ADCGet
000FB6  780200     MOV W0, W4
000FB8  780F04     MOV W4, [W14]
60:                    vsense2_raw = ADCGet( ADC_AIN3 );
000FBA  200010     MOV #0x1, W0
000FBC  07065B     RCALL ADCGet
000FBE  780200     MOV W0, W4
000FC0  980714     MOV W4, [W14+2]
61:                    
62:                    // Get vsense polynomial coefficient correction values.
63:                    CfgVsense1CoeffGet( &vsense1_coeff[ 0 ] );
000FC2  470270     ADD W14, #0x10, W4
000FC4  780004     MOV W4, W0
000FC6  07FF03     RCALL CfgVsense1CoeffGet
64:                    CfgVsense2CoeffGet( &vsense2_coeff[ 0 ] );
000FC8  200284     MOV #0x28, W4
000FCA  42020E     ADD W4, W14, W4
000FCC  780004     MOV W4, W0
000FCE  07FF17     RCALL CfgVsense2CoeffGet
65:                    
66:                    // Perform correction of vsense signals.
67:                    // vsense1_cor = UtilPolyMul( vsense1_raw, &vsense1_coeff[ 0 ], CFG_VSENSE1_COEFF_LEN );        COMMENTED OUT FOR DEBUGGING
68:                    // vsense2_cor = UtilPolyMul( vsense2_raw, &vsense2_coeff[ 0 ], CFG_VSENSE2_COEFF_LEN );        COMMENTED OUT FOR DEBUGGING
69:                    
70:                    // Construct the vsense CAN message.
71:                    vsense_msg.vsense1_raw = vsense1_raw;
000FD0  78021E     MOV [W14], W4
000FD2  980744     MOV W4, [W14+8]
72:                    vsense_msg.vsense1_cor = vsense1_cor;
000FD4  90022E     MOV [W14+4], W4
000FD6  980754     MOV W4, [W14+10]
73:                    vsense_msg.vsense2_raw = vsense2_raw;
000FD8  90021E     MOV [W14+2], W4
000FDA  980764     MOV W4, [W14+12]
74:                    vsense_msg.vsense2_cor = vsense2_cor;
000FDC  90023E     MOV [W14+6], W4
000FDE  980774     MOV W4, [W14+14]
75:                    
76:                    // Send the CAN message.
77:                    CANTxSet ( CAN_TX_MSG_VSENSE_DATA, vsense_msg.data_u16 );
000FE0  470268     ADD W14, #0x8, W4
000FE2  780084     MOV W4, W1
000FE4  200010     MOV #0x1, W0
000FE6  07038A     RCALL CANTxSet
78:                }
000FE8  FA8000     ULNK
000FEA  060000     RETURN
79:                
80:                // *****************************************************************************
81:                // ************************** Static Functions *********************************
82:                // *****************************************************************************
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/ver.c  ---------------------------
1:                 ////////////////////////////////////////////////////////////////////////////////
2:                 ///
3:                 /// @file   $FILE$
4:                 /// @author $AUTHOR$
5:                 /// @date   $DATE$
6:                 /// @brief  Source code file for defining hardware operation.   
7:                 ///
8:                 ////////////////////////////////////////////////////////////////////////////////
9:                 
10:                // *****************************************************************************
11:                // ************************** System Include Files *****************************
12:                // *****************************************************************************
13:                #include <xc.h>
14:                #include <stdbool.h>
15:                #include <stddef.h>
16:                #include <stdint.h>
17:                
18:                // *****************************************************************************
19:                // ************************** User Include Files *******************************
20:                // *****************************************************************************
21:                #include "ver.h"
22:                #include "can.h"
23:                
24:                // *****************************************************************************
25:                // ************************** Defines ******************************************
26:                // *****************************************************************************
27:                
28:                // *****************************************************************************
29:                // ************************** Global Variable Definitions **********************
30:                // *****************************************************************************
31:                
32:                // *****************************************************************************
33:                // ************************** File-Scope Variable Definitions ******************
34:                // *****************************************************************************
35:                static const uint8_t  node_type     = 1;    // Identified as 'Servo' Node.
36:                static const uint8_t  rev_ver       = 0;
37:                static const uint8_t  min_ver       = 0;
38:                static const uint8_t  maj_ver       = 0;
39:                static const uint32_t serial_num    = 0;    // Updated during manufacturing.
40:                
41:                // *****************************************************************************
42:                // ************************** Function Prototypes ******************************
43:                // *****************************************************************************
44:                
45:                // *****************************************************************************
46:                // ************************** Global Functions *********************************
47:                // *****************************************************************************
48:                
49:                // *****************************************************************************
50:                // ************************** Static Functions *********************************
51:                // *****************************************************************************
52:                void VerService ( void )
53:                {
002086  FA0008     LNK #0x8
54:                    CAN_TX_NODE_VER_U version_msg;
55:                    
56:                    // Construct the Version CAN message.
57:                    version_msg.node_type  = node_type;
002088  294864     MOV #0x9486, W4
00208A  784214     MOV.B [W4], W4
00208C  784F04     MOV.B W4, [W14]
58:                    version_msg.rev_ver    = rev_ver;
00208E  294874     MOV #0x9487, W4
002090  784214     MOV.B [W4], W4
002092  984714     MOV.B W4, [W14+1]
59:                    version_msg.min_ver    = min_ver;
002094  294884     MOV #0x9488, W4
002096  784214     MOV.B [W4], W4
002098  984724     MOV.B W4, [W14+2]
60:                    version_msg.maj_ver    = maj_ver;
00209A  294894     MOV #0x9489, W4
00209C  784214     MOV.B [W4], W4
00209E  984734     MOV.B W4, [W14+3]
61:                    version_msg.serial_num = serial_num;
0020A0  84A454     MOV 0x948A, W4
0020A2  84A465     MOV 0x948C, W5
0020A4  980724     MOV W4, [W14+4]
0020A6  980735     MOV W5, [W14+6]
62:                
63:                    // Send the Version message.
64:                    CANTxSet ( CAN_TX_MSG_NODE_VER, version_msg.data_u16 );
0020A8  78008E     MOV W14, W1
0020AA  200030     MOV #0x3, W0
0020AC  07FB27     RCALL CANTxSet
65:                }
0020AE  FA8000     ULNK
0020B0  060000     RETURN
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/util.c  --------------------------
1:                 ////////////////////////////////////////////////////////////////////////////////
2:                 ///
3:                 /// @file   $FILE$
4:                 /// @author $AUTHOR$
5:                 /// @date   $DATE$
6:                 /// @brief  Source code file for defining hardware operation.   
7:                 ///
8:                 ////////////////////////////////////////////////////////////////////////////////
9:                 
10:                // *****************************************************************************
11:                // ************************** System Include Files *****************************
12:                // *****************************************************************************
13:                #include <xc.h>
14:                #include <stdbool.h>
15:                #include <stddef.h>
16:                #include <stdint.h>
17:                #include <math.h>
18:                
19:                // *****************************************************************************
20:                // ************************** User Include Files *******************************
21:                // *****************************************************************************
22:                #include "hw.h"
23:                
24:                // *****************************************************************************
25:                // ************************** Defines ******************************************
26:                // *****************************************************************************
27:                
28:                // *****************************************************************************
29:                // ************************** Global Variable Definitions **********************
30:                // *****************************************************************************
31:                
32:                // *****************************************************************************
33:                // ************************** File-Scope Variable Definitions ******************
34:                // *****************************************************************************
35:                
36:                // *****************************************************************************
37:                // ************************** Function Prototypes ******************************
38:                // *****************************************************************************
39:                static long double UtilPow( uint16_t var, uint8_t pow );
40:                
41:                // *****************************************************************************
42:                // ************************** Global Functions *********************************
43:                // *****************************************************************************
44:                int16_t UtilPolyMul( uint16_t var, int32_t coeff[], uint8_t coeff_len )
45:                {
001D66  FA0010     LNK #0x10
001D68  BE9F88     MOV.D W8, [W15++]
001D6A  BE9F8A     MOV.D W10, [W15++]
001D6C  980750     MOV W0, [W14+10]
001D6E  980761     MOV W1, [W14+12]
001D70  984F62     MOV.B W2, [W14+14]
46:                    long double value;
47:                    uint8_t coeff_idx;
48:                    
49:                    for ( coeff_idx  = 0;
001D72  EB4200     CLR.B W4
001D74  984F04     MOV.B W4, [W14+8]
001D76  370019     BRA 0x1DAA
001DAA  904A8E     MOV.B [W14+8], W5
001DAC  904A6E     MOV.B [W14+14], W4
001DAE  52CF84     SUB.B W5, W4, [W15]
001DB0  36FFE3     BRA LEU, 0x1D78
50:                          coeff_idx <= coeff_len;
51:                          coeff_idx++ )
001DA4  904A0E     MOV.B [W14+8], W4
001DA6  E84204     INC.B W4, W4
001DA8  984F04     MOV.B W4, [W14+8]
52:                    {
53:                        value = UtilPow( var, coeff_idx ) * coeff[ coeff_idx ];
001D78  90488E     MOV.B [W14+8], W1
001D7A  90005E     MOV [W14+10], W0
001D7C  070039     RCALL _UtilPow
001D7E  BE0400     MOV.D W0, W8
001D80  BE0502     MOV.D W2, W10
001D82  904A0E     MOV.B [W14+8], W4
001D84  FB8204     ZE W4, W4
001D86  DD2242     SL W4, #2, W4
001D88  9002EE     MOV [W14+12], W5
001D8A  428204     ADD W5, W4, W4
001D8C  BE0214     MOV.D [W4], W4
001D8E  BE0004     MOV.D W4, W0
001D90  07F2CC     RCALL ___floatsidf
001D92  BE0200     MOV.D W0, W4
001D94  BE0302     MOV.D W2, W6
001D96  BE0008     MOV.D W8, W0
001D98  BE010A     MOV.D W10, W2
001D9A  07F2CC     RCALL ___muldf3
001D9C  BE0200     MOV.D W0, W4
001D9E  BE0302     MOV.D W2, W6
001DA0  BE9F04     MOV.D W4, [W14++]
001DA2  BE9706     MOV.D W6, [W14--]
54:                    }
55:                    
56:                    return ( (int16_t) value );
001DB2  BE003E     MOV.D [W14++], W0
001DB4  BE012E     MOV.D [W14--], W2
001DB6  07F28D     RCALL ___fixdfsi
001DB8  BE0200     MOV.D W0, W4
001DBA  780204     MOV W4, W4
57:                }
001DBC  780004     MOV W4, W0
001DBE  BE054F     MOV.D [--W15], W10
001DC0  BE044F     MOV.D [--W15], W8
001DC2  FA8000     ULNK
001DC4  060000     RETURN
58:                
59:                // Note: internal scaling by 10 is performed; input parameter 'ms_delay'
60:                // should no exceed ~6000.
61:                void UtilDelay( uint16_t ms_delay )
62:                {
001DC6  FA0008     LNK #0x8
001DC8  980730     MOV W0, [W14+6]
63:                    uint16_t start_time;
64:                    uint16_t psnt_time;
65:                    uint16_t p1ms_delay;
66:                    
67:                    // Scale delay time to resolution of Timer1 (i.e. 1ms -> 0.1ms).
68:                    p1ms_delay = ms_delay * 10;
001DCA  90023E     MOV [W14+6], W4
001DCC  B922EA     MUL.SU W4, #10, W4
001DCE  980714     MOV W4, [W14+2]
69:                    
70:                    // Initialize timers for identifying delay time.
71:                    start_time = HwTMRp1msGet();
001DD0  07FF78     RCALL HwTMRp1msGet
001DD2  780200     MOV W0, W4
001DD4  980724     MOV W4, [W14+4]
72:                    psnt_time  = start_time;
001DD6  90022E     MOV [W14+4], W4
001DD8  780F04     MOV W4, [W14]
73:                    
74:                    // Wait for the delay time to elapse before exiting the function.
75:                    //
76:                    // Note: Condition is 'less than or equal to' to guarantee delay time will
77:                    // elapse.  For example, with input parameter 'ms_delay' = 5, the time
78:                    // elapsed will be 5.0-5.1ms.
79:                    //
80:                    while ( psnt_time - start_time <= p1ms_delay )
001DDA  370003     BRA 0x1DE2
001DE2  90022E     MOV [W14+4], W4
001DE4  12029E     SUBR W4, [W14], W5
001DE6  90021E     MOV [W14+2], W4
001DE8  528F84     SUB W5, W4, [W15]
001DEA  36FFF8     BRA LEU, 0x1DDC
81:                    {
82:                        psnt_time = HwTMRp1msGet();
001DDC  07FF72     RCALL HwTMRp1msGet
001DDE  780200     MOV W0, W4
001DE0  780F04     MOV W4, [W14]
83:                    }
84:                }
001DEC  FA8000     ULNK
001DEE  060000     RETURN
85:                
86:                // *****************************************************************************
87:                // ************************** Static Functions *********************************
88:                // *****************************************************************************
89:                static long double UtilPow( uint16_t var, uint8_t pow )
90:                {
001DF0  FA000C     LNK #0xC
001DF2  BE9F88     MOV.D W8, [W15++]
001DF4  BE9F8A     MOV.D W10, [W15++]
001DF6  980740     MOV W0, [W14+8]
001DF8  984F21     MOV.B W1, [W14+10]
91:                    long double result;
92:                    
93:                    result = powl( (long double) var, (long double) pow );
001DFA  904A2E     MOV.B [W14+10], W4
001DFC  FB8204     ZE W4, W4
001DFE  200005     MOV #0x0, W5
001E00  BE0004     MOV.D W4, W0
001E02  07F296     RCALL ___floatunsidf
001E04  BE0400     MOV.D W0, W8
001E06  BE0502     MOV.D W2, W10
001E08  90024E     MOV [W14+8], W4
001E0A  200005     MOV #0x0, W5
001E0C  BE0004     MOV.D W4, W0
001E0E  07F290     RCALL ___floatunsidf
001E10  BE0208     MOV.D W8, W4
001E12  BE030A     MOV.D W10, W6
001E14  07F304     RCALL _powl
001E16  BE0200     MOV.D W0, W4
001E18  BE0302     MOV.D W2, W6
001E1A  BE9F04     MOV.D W4, [W14++]
001E1C  BE9706     MOV.D W6, [W14--]
94:                    
95:                    return result;
001E1E  BE023E     MOV.D [W14++], W4
001E20  BE032E     MOV.D [W14--], W6
96:                }
001E22  BE0004     MOV.D W4, W0
001E24  BE0106     MOV.D W6, W2
001E26  BE054F     MOV.D [--W15], W10
001E28  BE044F     MOV.D [--W15], W8
001E2A  FA8000     ULNK
001E2C  060000     RETURN
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/servo.c  -------------------------
1:                 ////////////////////////////////////////////////////////////////////////////////
2:                 ///
3:                 /// @file   $FILE$
4:                 /// @author $AUTHOR$
5:                 /// @date   $DATE$
6:                 /// @brief  Source code file for defining hardware operation.   
7:                 ///
8:                 ////////////////////////////////////////////////////////////////////////////////
9:                 
10:                // *****************************************************************************
11:                // ************************** System Include Files *****************************
12:                // *****************************************************************************
13:                #include <xc.h>
14:                #include <stdbool.h>
15:                #include <stddef.h>
16:                #include <stdint.h>
17:                
18:                // *****************************************************************************
19:                // ************************** User Include Files *******************************
20:                // *****************************************************************************
21:                #include "servo.h"
22:                #include "ina219.h"
23:                #include "can.h"
24:                #include "cfg.h"
25:                #include "util.h"
26:                #include "pwm.h"
27:                
28:                // *****************************************************************************
29:                // ************************** Defines ******************************************
30:                // *****************************************************************************
31:                
32:                // *****************************************************************************
33:                // ************************** Global Variable Definitions **********************
34:                // *****************************************************************************
35:                
36:                // *****************************************************************************
37:                // ************************** File-Scope Variable Definitions ******************
38:                // *****************************************************************************
39:                static uint16_t servo_cmd_type;
40:                static uint16_t servo_cmd_pwm;
41:                static int16_t  servo_cmd_pos;
42:                static uint16_t servo_act_pwm;
43:                
44:                // *****************************************************************************
45:                // ************************** Function Prototypes ******************************
46:                // *****************************************************************************
47:                void ServoService ( void )
48:                {
001FEE  FA002E     LNK #0x2E
49:                    CAN_TX_SERVO_CMD_U    servo_cmd_msg;
50:                    CAN_TX_SERVO_STATUS_U servo_status_msg;
51:                    
52:                    uint16_t servo_amperage;
53:                    uint16_t servo_voltage;
54:                    
55:                    int32_t servo_coeff[ CFG_PWM_COEFF_LEN ];
56:                    
57:                    bool payload_valid;
58:                    
59:                    // Get servo amperage and voltage.
60:                    servo_amperage = INA219AmpGet();
001FF0  07FF8B     RCALL INA219AmpGet
001FF2  780200     MOV W0, W4
001FF4  780F04     MOV W4, [W14]
61:                    servo_voltage  = INA219VoltGet();
001FF6  07FF8D     RCALL INA219VoltGet
001FF8  780200     MOV W0, W4
001FFA  980714     MOV W4, [W14+2]
62:                    
63:                    // Get the Servo Command CAN data.
64:                    payload_valid =  CANRxGet ( CAN_RX_MSG_SERVO_CMD, servo_cmd_msg.data_u16 );
001FFC  470266     ADD W14, #0x6, W4
001FFE  780084     MOV W4, W1
002000  EB0000     CLR W0
002002  07FBCF     RCALL CANRxGet
002004  784200     MOV.B W0, W4
002006  984744     MOV.B W4, [W14+4]
65:                    
66:                    // Servo Command CAN message received ?
67:                    if( payload_valid == true )
002008  90424E     MOV.B [W14+4], W4
00200A  524FE0     SUB.B W4, #0x0, [W15]
00200C  320006     BRA Z, 0x201A
68:                    {
69:                        // Update module data with that received.
70:                        servo_cmd_type = servo_cmd_msg.cmd_type;
00200E  90023E     MOV [W14+6], W4
002010  88A284     MOV W4, servo_cmd_type
71:                        servo_cmd_pwm  = servo_cmd_msg.cmd_pwm;
002012  90024E     MOV [W14+8], W4
002014  88A294     MOV W4, servo_cmd_pwm
72:                        servo_cmd_pos  = servo_cmd_msg.cmd_pos;
002016  90025E     MOV [W14+10], W4
002018  88A2A4     MOV W4, servo_cmd_pos
73:                    }
74:                    
75:                    // Position command is being used for control ?
76:                    if( servo_cmd_type == 1 )
00201A  80A284     MOV servo_cmd_type, W4
00201C  520FE1     SUB W4, #0x1, [W15]
00201E  3A0004     BRA NZ, 0x2028
77:                    {
78:                        // Get servo polynomial coefficient correction values.
79:                        CfgPWMCoeffGet( &servo_coeff[ 0 ] );
002020  470276     ADD W14, #0x16, W4
002022  780004     MOV W4, W0
002024  07F6BC     RCALL CfgPWMCoeffGet
002026  370002     BRA 0x202C
80:                        
81:                        // Perform correction of position commanded value.
82:                        // servo_act_pwm = UtilPolyMul( servo_cmd_pos, &servo_coeff[ 0 ], CFG_PWM_COEFF_LEN );  COMMENTED OUT FOR DEBUGGING
83:                    }
84:                    else
85:                    {
86:                        // Commanded PWM is used directly for control.
87:                        servo_act_pwm = servo_cmd_pwm;
002028  80A294     MOV servo_cmd_pwm, W4
00202A  88A2B4     MOV W4, servo_act_pwm
88:                    }
89:                    
90:                    // Update PWM duty cycle with that determined.
91:                    PWMDutySet( servo_act_pwm );
00202C  80A2B4     MOV servo_act_pwm, W4
00202E  780004     MOV W4, W0
002030  07FF36     RCALL PWMDutySet
92:                
93:                    // Construct the Servo Status CAN message.
94:                    servo_status_msg.cmd_type_echo = servo_cmd_msg.cmd_type;
002032  90023E     MOV [W14+6], W4
002034  980774     MOV W4, [W14+14]
95:                    servo_status_msg.pwm_act       = servo_act_pwm;
002036  80A2B4     MOV servo_act_pwm, W4
002038  980F04     MOV W4, [W14+16]
96:                    servo_status_msg.servo_voltage = servo_voltage;
00203A  90021E     MOV [W14+2], W4
00203C  980F14     MOV W4, [W14+18]
97:                    servo_status_msg.servo_current = servo_amperage;
00203E  78021E     MOV [W14], W4
002040  980F24     MOV W4, [W14+20]
98:                    
99:                    // Send the CAN message.
100:                   CANTxSet ( CAN_TX_MSG_SERVO_STATUS, servo_status_msg.data_u16 );
002042  47026E     ADD W14, #0xE, W4
002044  780084     MOV W4, W1
002046  EB0000     CLR W0
002048  07FB59     RCALL CANTxSet
101:               }
00204A  FA8000     ULNK
00204C  060000     RETURN
102:               
103:               // *****************************************************************************
104:               // ************************** Global Functions *********************************
105:               // *****************************************************************************
106:               
107:               // *****************************************************************************
108:               // ************************** Static Functions *********************************
109:               // *****************************************************************************
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/rst.c  ---------------------------
1:                 
2:                 ////////////////////////////////////////////////////////////////////////////////
3:                 ///
4:                 /// @file   $FILE$
5:                 /// @author $AUTHOR$
6:                 /// @date   $DATE$
7:                 /// @brief  Source code file for defining hardware operation.   
8:                 ///
9:                 ////////////////////////////////////////////////////////////////////////////////
10:                
11:                // *****************************************************************************
12:                // ************************** System Include Files *****************************
13:                // *****************************************************************************
14:                #include <xc.h>
15:                #include <stdbool.h>
16:                #include <stddef.h>
17:                #include <stdint.h>
18:                
19:                // *****************************************************************************
20:                // ************************** User Include Files *******************************
21:                // *****************************************************************************
22:                #include "rst.h"
23:                #include "can.h"
24:                
25:                // *****************************************************************************
26:                // ************************** Defines ******************************************
27:                // *****************************************************************************
28:                
29:                // The Reset Control Register (RCON) contains flags identifying reset conditions
30:                // in addition to other status registers.  The mask defines values for
31:                // selecting only the applicable reset condition bits from the RCON register.
32:                //
33:                //  bit 15 - TRAPR: Trap Reset Flag bit
34:                //  bit 14 - IOPUWR: Set for the following conditions:
35:                //              * Illegal Opcode Reset
36:                //              * Illegal Address Mode Reset
37:                //              * Uninitialized W Register Access Reset
38:                //              * Security Reset
39:                //  bit  9 - CM: Configuration Mismatch Flag bit
40:                //  bit  7 - EXTR: External Reset (MCLR) Pin bit
41:                //  bit  6 - SWR: Software RESET (Instruction) Flag bit
42:                //  bit  4 - WDTO: Watchdog Timer Time-out Flag bit
43:                //  bit  1 - BOR: Brown-out Reset Flag bit
44:                //  bit  0 - POR: Power-on Reset Flag bit
45:                //
46:                #define RST_MASK            0xC2D3
47:                #define RST_MASK_POR        0x0001
48:                #define RST_MASK_BOR        0x0002
49:                #define RST_MASK_SWR        0x0040
50:                #define RST_MASK_SW_FAULT   0xC290
51:                
52:                // *****************************************************************************
53:                // ************************** Global Variable Definitions **********************
54:                // *****************************************************************************
55:                
56:                // *****************************************************************************
57:                // ************************** File-Scope Variable Definitions ******************
58:                // *****************************************************************************
59:                static uint16_t rst_cond; 
60:                static uint16_t rst_detail; 
61:                
62:                // *****************************************************************************
63:                // ************************** Function Prototypes ******************************
64:                // *****************************************************************************
65:                
66:                // *****************************************************************************
67:                // ************************** Global Functions *********************************
68:                // *****************************************************************************
69:                void RSTStartup ( void )
70:                {
001F1C  FA0000     LNK #0x0
71:                    // Update the reset detail with the applicable bits from the Reset
72:                    // Control Register.
73:                    rst_detail = RCON & RST_MASK;
001F1E  803A05     MOV RCON, W5
001F20  2C2D34     MOV #0xC2D3, W4
001F22  628204     AND W5, W4, W4
001F24  88A314     MOV W4, rst_detail
74:                    
75:                    // Clear the reset condition bits so that the condition can be identified
76:                    // on the next processor reset.
77:                    RCON &= ~RST_MASK;
001F26  803A05     MOV RCON, W5
001F28  23D2C4     MOV #0x3D2C, W4
001F2A  628204     AND W5, W4, W4
001F2C  883A04     MOV W4, RCON
78:                    
79:                    // Roll-up the reset detail into an easily recognizable identification 
80:                    // of what caused the reset condition.
81:                    //
82:                    // Note: The ordering of the if-else conditions are necessary for expected
83:                    // reset condition identification, since multiple bits within the reset
84:                    // detail can be set (e.g. both POR and BOR are set on a power-on reset
85:                    // condition).  The priority of annunciation is apparent from the ordering
86:                    // of statements within the if-else conditions.
87:                    //
88:                    if( ( rst_detail & RST_MASK_POR ) != 0 )
001F2E  80A314     MOV rst_detail, W4
001F30  620261     AND W4, #0x1, W4
001F32  784204     MOV.B W4, W4
001F34  524FE0     SUB.B W4, #0x0, [W15]
001F36  320003     BRA Z, 0x1F3E
89:                    {
90:                        rst_cond = 1U;
001F38  200014     MOV #0x1, W4
001F3A  88A304     MOV W4, rst_cond
001F3C  370019     BRA 0x1F70
91:                    }
92:                    else
93:                    if( ( rst_detail & RST_MASK_BOR ) != 0 )
001F3E  80A314     MOV rst_detail, W4
001F40  620262     AND W4, #0x2, W4
001F42  520FE0     SUB W4, #0x0, [W15]
001F44  320003     BRA Z, 0x1F4C
94:                    {
95:                        rst_cond = 2U;
001F46  200024     MOV #0x2, W4
001F48  88A304     MOV W4, rst_cond
001F4A  370012     BRA 0x1F70
96:                    }
97:                    else
98:                    if( ( rst_detail & RST_MASK_SWR ) != 0 )
001F4C  80A315     MOV rst_detail, W5
001F4E  200404     MOV #0x40, W4
001F50  628204     AND W5, W4, W4
001F52  520FE0     SUB W4, #0x0, [W15]
001F54  320003     BRA Z, 0x1F5C
99:                    {
100:                       rst_cond = 3U;
001F56  200034     MOV #0x3, W4
001F58  88A304     MOV W4, rst_cond
001F5A  37000A     BRA 0x1F70
101:                   }
102:                   else
103:                   if( ( rst_detail & RST_MASK_SW_FAULT ) != 0 )
001F5C  80A315     MOV rst_detail, W5
001F5E  2C2904     MOV #0xC290, W4
001F60  628204     AND W5, W4, W4
001F62  520FE0     SUB W4, #0x0, [W15]
001F64  320003     BRA Z, 0x1F6C
104:                   {
105:                       rst_cond = 4U;
001F66  200044     MOV #0x4, W4
001F68  88A304     MOV W4, rst_cond
001F6A  370002     BRA 0x1F70
106:                   }
107:                   else
108:                   {
109:                       // Note: else-clause included for completeness.  All processor resets
110:                       // should result in a reset condition being identified.
111:                       rst_cond = 0U;
001F6C  EB0200     CLR W4
001F6E  88A304     MOV W4, rst_cond
112:                   }
113:               }
001F70  FA8000     ULNK
001F72  060000     RETURN
114:               
115:               void RSTService ( void )
116:               {
001F74  FA0008     LNK #0x8
117:                   CAN_TX_NODE_STATUS_U node_status_msg;
118:                   
119:                   // Construct the Node Status CAN message.
120:                   node_status_msg.reset_condition = rst_cond;
001F76  80A304     MOV rst_cond, W4
001F78  780F04     MOV W4, [W14]
121:                   node_status_msg.reset_detail    = rst_detail;
001F7A  80A314     MOV rst_detail, W4
001F7C  980714     MOV W4, [W14+2]
122:                   
123:                   // Send the Node Status message.
124:                   CANTxSet ( CAN_TX_MSG_NODE_STATUS, node_status_msg.data_u16 );
001F7E  78008E     MOV W14, W1
001F80  200020     MOV #0x2, W0
001F82  07FBBC     RCALL CANTxSet
125:               }
001F84  FA8000     ULNK
001F86  060000     RETURN
126:               
127:               // *****************************************************************************
128:               // ************************** Static Functions *********************************
129:               // *****************************************************************************
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/pwm.c  ---------------------------
1:                 
2:                 ////////////////////////////////////////////////////////////////////////////////
3:                 ///
4:                 /// @file   $FILE$
5:                 /// @author $AUTHOR$
6:                 /// @date   $DATE$
7:                 /// @brief  Source code file for defining hardware operation.   
8:                 ///
9:                 ////////////////////////////////////////////////////////////////////////////////
10:                
11:                // *****************************************************************************
12:                // ************************** System Include Files *****************************
13:                // *****************************************************************************
14:                #include <xc.h>
15:                #include <stdbool.h>
16:                #include <stddef.h>
17:                #include <stdint.h>
18:                
19:                // *****************************************************************************
20:                // ************************** User Include Files *******************************
21:                // *****************************************************************************
22:                #include "pwm.h"
23:                
24:                // *****************************************************************************
25:                // ************************** Defines ******************************************
26:                // *****************************************************************************
27:                
28:                // *****************************************************************************
29:                // ************************** Global Variable Definitions **********************
30:                // *****************************************************************************
31:                
32:                // *****************************************************************************
33:                // ************************** File-Scope Variable Definitions ******************
34:                // *****************************************************************************
35:                
36:                // *****************************************************************************
37:                // ************************** Function Prototypes ******************************
38:                // *****************************************************************************
39:                
40:                // *****************************************************************************
41:                // ************************** Global Functions *********************************
42:                // *****************************************************************************
43:                void PWMInit ( void )
44:                {
001E2E  FA0000     LNK #0x0
45:                    // Disable the PWM module.
46:                    //
47:                    // Note: Should already be disabled out of reset; setting is included for
48:                    // robustness.
49:                    //
50:                    PTCONbits.PTEN = 0;
001E30  A9EC01     BCLR 0xC01, #7
51:                    
52:                    PTCONbits.PTSIDL    = 0;    // N/A, b/c CPU idle mode not used.
001E32  A9AC01     BCLR 0xC01, #5
53:                    PTCONbits.SEIEN     = 0;    // Special event interrupt is disabled.
001E34  A96C01     BCLR 0xC01, #3
54:                    PTCONbits.EIPU      = 0;    // N/A, b/c ITB = 1.
001E36  A94C01     BCLR 0xC01, #2
55:                    PTCONbits.SYNCPOL   = 0;    // N/A, External synchronization not used.
001E38  A92C01     BCLR 0xC01, #1
56:                    PTCONbits.SYNCOEN   = 0;    // SYNCO output is disabled.
001E3A  A90C01     BCLR 0xC01, #0
57:                    PTCONbits.SYNCEN    = 0;    // External synchronization of time base disabled.
001E3C  A9EC00     BCLR PTCON, #7
58:                    PTCONbits.SYNCSRC   = 0;    // N/A, b/c external synchronization not used.
001E3E  806004     MOV PTCON, W4
001E40  A14004     BCLR W4, #4
001E42  A15004     BCLR W4, #5
001E44  A16004     BCLR W4, #6
001E46  886004     MOV W4, PTCON
59:                    PTCONbits.SEVTPS    = 0;    // N/A, b/c special event trigger not used.
001E48  806004     MOV PTCON, W4
001E4A  A10004     BCLR W4, #0
001E4C  A11004     BCLR W4, #1
001E4E  A12004     BCLR W4, #2
001E50  A13004     BCLR W4, #3
001E52  886004     MOV W4, PTCON
60:                    
61:                    // Fosc = 40MHz
62:                    // Fpwm = 50Hz
63:                    //
64:                    // Fcnt := PWM counter frequency (i.e. resolution of the PWM).
65:                    // 
66:                    // Fcnt = Fosc  / PCLKDIV
67:                    //      = 40MHz / 16
68:                    //      = 2.5MHz
69:                    //
70:                    // PHASE3 = Fcnt   / Fpwm
71:                    //        = 2.5MHz / 50Hz
72:                    //        = 50000
73:                    //
74:                    // PDC3 = PHASE3 * Fpwm * 1.5ms
75:                    //      = 50000  * 50Hz * 1.5ms
76:                    //      = 3750
77:                    //
78:                    // Note: A PWM prescaler is chosen which gives the greatest PWM resolution
79:                    // without overflowing the 16-bit period selection register 'PHASE3'.
80:                    //
81:                    // Note: An initial PWM duty cycle is selected for the neutral (i.e. 1.5ms)
82:                    // position.
83:                    //
84:                    PTCON2bits.PCLKDIV  = 0b100;    // Select the PWM perscaler (0b100 = 16 div).
001E54  806014     MOV PTCON2, W4
001E56  A10004     BCLR W4, #0
001E58  A11004     BCLR W4, #1
001E5A  A02004     BSET W4, #2
001E5C  886014     MOV W4, PTCON2
85:                    PHASE3              = 50000;    // Select the PWM period.
001E5E  2C3504     MOV #0xC350, W4
001E60  886344     MOV W4, PHASE3
86:                    PDC3                = 3750;     // Select the PWM duty cycle.
001E62  20EA64     MOV #0xEA6, W4
001E64  886334     MOV W4, PDC3
87:                    
88:                    CHOPbits.CHPCLKEN = 0; // Chop clock generator is disabled.
001E66  A9EC1B     BCLR 0xC1B, #7
89:                    
90:                    PWMCON3bits.FLTIEN  = 0;    // Fault interrupts disabled.
001E68  A98C61     BCLR 0xC61, #4
91:                    PWMCON3bits.CLIEN   = 0;    // Current-limit interrupt disabled.
001E6A  A96C61     BCLR 0xC61, #3
92:                    PWMCON3bits.TRGIEN  = 0;    // Trigger interrupt disabled.
001E6C  A94C61     BCLR 0xC61, #2
93:                    PWMCON3bits.ITB     = 1;    // Select independent time base mode; PWM3 period set with register 'PHASE3'.
001E6E  A82C61     BSET 0xC61, #1
94:                    PWMCON3bits.MDCS    = 0;    // Select independent duty cycle; PWM3 duty cycle set with register 'PDC3'.
001E70  A90C61     BCLR 0xC61, #0
95:                    PWMCON3bits.DTC     = 0b10; // Dead time function is disabled.
001E72  806304     MOV PWMCON3, W4
001E74  A16004     BCLR W4, #6
001E76  A07004     BSET W4, #7
001E78  886304     MOV W4, PWMCON3
96:                    PWMCON3bits.DTCP    = 0;    // N/A, b/c DTC = 0b10.
001E7A  A9AC60     BCLR PWMCON3, #5
97:                    PWMCON3bits.CAM     = 0;    // Edge-aligned mode is enabled (i.e. not center-aligned mode).
001E7C  A94C60     BCLR PWMCON3, #2
98:                    PWMCON3bits.XPRES   = 0;    // External pins do not affect PWM3 time base.
001E7E  A92C60     BCLR PWMCON3, #1
99:                    PWMCON3bits.IUE     = 0;    // Updates to the period (PHASE3) and duty cycle (PDC3) registers are synchronized to the PMW3 period boundary.
001E80  A90C60     BCLR PWMCON3, #0
100:                   
101:                   // PWM3 I/O Control Register
102:                   // 
103:                   //  bits    15: PENH   =  0 - PWM3H pin controlled by GPIO module.
104:                   //  bits    14: PENL   =  1 - PWM3L pin controlled by PWM3 module.
105:                   //  bits    13: POLH   =  0 - N/A, b/c PENH = 0.
106:                   //  bits    12: POLL   =  0 - PWM3L pin is active-high.
107:                   //  bits 11-10: PMOD   = 01 - Redundant output mode.
108:                   //  bits     9: OVRENH =  0 - N/A, b/c PENH = 0.
109:                   //  bits     8: OVRENL =  0 - Override disabled, PWM3 generator sets PWM3L.
110:                   //  bits  7- 6: OVRDAT = 00 - N/A, b/c OVRENL = 0.
111:                   //  bits  5- 4: FLTDAT = 00 - N/A, b/c FLTMOD = 0.
112:                   //  bits  3- 2: CLDAT  = 00 - N/A, b/c CLMOD = 0.
113:                   //  bits     1: SWAP   =  0 - No swap, pins PWM3H/L mapped to respective pins.
114:                   //  bits     0: OSYNC  =  0 - N/A, b/c OVRENL = 0.
115:                   //
116:                   // Note: modification of the IOCON3 register is write protected.  A unlock
117:                   // sequence is required before writing the register in which the '0xABCD' 
118:                   // and '0x1234' keys must be written to the PWMKEY register before IOCON3 
119:                   // can be written.  Writing of the IOCON3 must be the next SFR access after
120:                   // the unlock sequence.
121:                   //
122:                   PWMKEY = 0xABCD;
001E82  2ABCD4     MOV #0xABCD, W4
001E84  8860F4     MOV W4, PWMKEY
123:                   PWMKEY = 0x1234;
001E86  212344     MOV #0x1234, W4
001E88  8860F4     MOV W4, PWMKEY
124:                   IOCON3 = 0x4400;
001E8A  244004     MOV #0x4400, W4
001E8C  886314     MOV W4, IOCON3
125:                   
126:                   AUXCON3bits.CHOPHEN = 0; // PWM3H chopping function is disabled.
001E8E  A92C7E     BCLR AUXCON3, #1
127:                   AUXCON3bits.CHOPLEN = 0; // PWM3L chopping function is disabled.
001E90  A90C7E     BCLR AUXCON3, #0
128:               }
001E92  FA8000     ULNK
001E94  060000     RETURN
129:               
130:               void PWMEnable ( void )
131:               {
001E96  FA0000     LNK #0x0
132:                   // Enable the PWM module.
133:                   //
134:                   // Note: Independent function for enabling of PWM modules allows for
135:                   // synchronization with control-flow processing.
136:                   //
137:                   PTCONbits.PTEN = 1;
001E98  A8EC01     BSET 0xC01, #7
138:               }
001E9A  FA8000     ULNK
001E9C  060000     RETURN
139:               
140:               void PWMDutySet ( uint16_t pwm_duty )
141:               {
001E9E  FA0002     LNK #0x2
001EA0  780F00     MOV W0, [W14]
142:                   // Update the hardware register setting for the PWM duty cycle.
143:                   //
144:                   // Note: PWM hardware configuration selected for 2.5MHz (0.4us) resolution.
145:                   // Therefore, input parameter (1us LSB) must be scaled by 2.5 for
146:                   // interfacing with hardware configuration.
147:                   //
148:                   // Note: Immediate vs. period-synchronized updating selected in
149:                   // register bit 'PWMCON3.IUE'.
150:                   //
151:                   PDC3 = ( pwm_duty * 5U ) / 2U;
001EA2  78021E     MOV [W14], W4
001EA4  B922E5     MUL.SU W4, #5, W4
001EA6  D10204     LSR W4, W4
001EA8  886334     MOV W4, PDC3
152:               }
001EAA  FA8000     ULNK
001EAC  060000     RETURN
153:               
154:               // *****************************************************************************
155:               // ************************** Static Functions *********************************
156:               // *****************************************************************************
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/nvm.c  ---------------------------
1:                 
2:                 ////////////////////////////////////////////////////////////////////////////////
3:                 ///
4:                 /// @file   $FILE$
5:                 /// @author $AUTHOR$
6:                 /// @date   $DATE$
7:                 /// @brief    
8:                 ///
9:                 ////////////////////////////////////////////////////////////////////////////////
10:                
11:                // *****************************************************************************
12:                // ************************** System Include Files *****************************
13:                // *****************************************************************************
14:                #include <xc.h>
15:                #include <stdbool.h>
16:                #include <stddef.h>
17:                #include <stdint.h>
18:                
19:                // *****************************************************************************
20:                // ************************** User Include Files *******************************
21:                // *****************************************************************************
22:                #include "nvm.h"
23:                #include "wdt.h"
24:                #include "hw.h"
25:                
26:                // *****************************************************************************
27:                // ************************** Defines ******************************************
28:                // *****************************************************************************
29:                
30:                // *****************************************************************************
31:                // ************************** Global Variable Definitions **********************
32:                // *****************************************************************************
33:                
34:                // *****************************************************************************
35:                // ************************** File-Scope Variable Definitions ******************
36:                // *****************************************************************************
37:                
38:                // *****************************************************************************
39:                // ************************** Function Prototypes ******************************
40:                // *****************************************************************************
41:                
42:                // *****************************************************************************
43:                // ************************** Global Functions *********************************
44:                // *****************************************************************************
45:                void NVMInit ( void )
46:                {
0019A2  FA0000     LNK #0x0
47:                    NVMCONbits.WREN    = 1;     // Enabled program/erase operations.
0019A4  A8C729     BSET 0x729, #6
48:                    NVMCONbits.NVMSIDL = 0;     // N/A, since idle mode not entered.  Set to continue Flash operations when in idle mode for robustness.
0019A6  A98729     BCLR 0x729, #4
49:                    NVMCONbits.RPDF    = 0;     // Data is stored in RAM in an uncompressed format.
0019A8  A92729     BCLR 0x729, #1
50:                }
0019AA  FA8000     ULNK
0019AC  060000     RETURN
51:                
52:                bool NVMErasePage ( uint16_t table_page, 
53:                                    uint16_t table_offset )
54:                {
0019AE  FA0006     LNK #0x6
0019B0  980710     MOV W0, [W14+2]
0019B2  980721     MOV W1, [W14+4]
55:                    bool nvm_error = false;
0019B4  EB4200     CLR.B W4
0019B6  784F04     MOV.B W4, [W14]
56:                    
57:                    // Load the address of the erased page.
58:                    NVMADRU = table_page;
0019B8  90021E     MOV [W14+2], W4
0019BA  883964     MOV W4, NVMADRU
59:                    NVMADR  = table_offset;
0019BC  90022E     MOV [W14+4], W4
0019BE  883954     MOV W4, NVMADR
60:                    
61:                    // Select a Memory page erase operation.
62:                    NVMCONbits.NVMOP = 0b0011;
0019C0  803944     MOV NVMCON, W4
0019C2  A00004     BSET W4, #0
0019C4  A01004     BSET W4, #1
0019C6  A12004     BCLR W4, #2
0019C8  A13004     BCLR W4, #3
0019CA  883944     MOV W4, NVMCON
63:                    
64:                    // Disable control flow execution.  
65:                    // - interrupts
66:                    // - watchdog timer
67:                    // - timer1
68:                    //
69:                    // This is performed to maintain expected control flow through CPU stall.
70:                    // The CPU stalls until the erase operation is finished. The CPU will 
71:                    // not execute any instructions or respond to interrupts during this time. 
72:                    // If any interrupts occur during the programming cycle, they will remain
73:                    // pending until the cycle completes.
74:                    //
75:                    __builtin_disi( 0x3FFF );
0019CC  FC3FFF     DISI #0x3FFF
76:                    WDTDisable();
0019CE  070378     RCALL WDTDisable
77:                    HwTMRDisable();
0019D0  070168     RCALL HwTMRDisable
78:                    
79:                    // Perform unlock sequence and initiate starting the program/erase cycle.
80:                    //
81:                    // NOTE: The CPU stalls until the erase operation is finished. The CPU will 
82:                    // not execute any instructions or respond to interrupts during this time. 
83:                    // If any interrupts occur during the programming cycle, they will remain
84:                    // pending until the cycle completes.
85:                    //
86:                    NVMKEY = 0x55;
0019D2  200554     MOV #0x55, W4
0019D4  883974     MOV W4, NVMKEY
87:                    NVMKEY = 0xAA;
0019D6  200AA4     MOV #0xAA, W4
0019D8  883974     MOV W4, NVMKEY
88:                    NVMCONbits.WR = 1;
0019DA  A8E729     BSET 0x729, #7
89:                    
90:                    // Two NOP instructions are required after starting the program/erase cycle.
91:                    __builtin_nop();
0019DC  000000     NOP
92:                    __builtin_nop();
0019DE  000000     NOP
93:                    
94:                    // Wait for the erase cycle to be completed by the hardware
95:                    while( NVMCONbits.WR == 1 );
0019E0  000000     NOP
0019E2  803945     MOV NVMCON, W5
0019E4  280004     MOV #0x8000, W4
0019E6  628204     AND W5, W4, W4
0019E8  520FE0     SUB W4, #0x0, [W15]
0019EA  3AFFFB     BRA NZ, 0x19E2
96:                    
97:                    // Re-enable control flow execution:
98:                    // - interrupts
99:                    // - watchdog timer
100:                   // - timer1
101:                   __builtin_disi( 0 );
0019EC  FC0000     DISI #0x0
102:                   WDTEnable();
0019EE  070365     RCALL WDTEnable
103:                   HwTMREnable();
0019F0  070153     RCALL HwTMREnable
104:                   
105:                   // Identify an NVM erase error if the hardware indicates an improper
106:                   // erase sequence attempted.
107:                   if( NVMCONbits.WRERR == 1 )
0019F2  803945     MOV NVMCON, W5
0019F4  220004     MOV #0x2000, W4
0019F6  628204     AND W5, W4, W4
0019F8  520FE0     SUB W4, #0x0, [W15]
0019FA  320002     BRA Z, 0x1A00
108:                   {
109:                       nvm_error = true;
0019FC  B3C014     MOV.B #0x1, W4
0019FE  784F04     MOV.B W4, [W14]
110:                   }
111:                   
112:                   return nvm_error;
001A00  78421E     MOV.B [W14], W4
113:               }
001A02  784004     MOV.B W4, W0
001A04  FA8000     ULNK
001A06  060000     RETURN
114:               
115:               bool NVMProgramPage ( const uint16_t src_data[],
116:                                     uint16_t table_page, 
117:                                     uint16_t table_offset )
118:               {
001A08  FA000E     LNK #0xE
001A0A  980740     MOV W0, [W14+8]
001A0C  980751     MOV W1, [W14+10]
001A0E  980762     MOV W2, [W14+12]
119:                   uint16_t  program_dword_idx;
120:                   bool      nvm_error = false;
001A10  EB4200     CLR.B W4
001A12  984724     MOV.B W4, [W14+2]
121:                   
122:                   uint16_t src_idx = 1;
001A14  200014     MOV #0x1, W4
001A16  980724     MOV W4, [W14+4]
123:                   uint16_t tblpag_store;
124:                   
125:                   // Increment through the Program Page (1024 words), one row 
126:                   // (128 words) at a time.
127:                   for( program_dword_idx = 0;
001A18  EB0200     CLR W4
001A1A  780F04     MOV W4, [W14]
001A1C  370031     BRA 0x1A80
001A80  201FF4     MOV #0x1FF, W4
001A82  78029E     MOV [W14], W5
001A84  528F84     SUB W5, W4, [W15]
001A86  36FFCB     BRA LEU, 0x1A1E
128:                        program_dword_idx < 512;
129:                        program_dword_idx++ )
001A7E  E80F1E     INC [W14], [W14]
130:                   {
131:                       // src_idx = src_idx + 1;
132:                       
133:                       // Load the NVM destination address.
134:                       NVMADRU = table_page;
001A1E  90025E     MOV [W14+10], W4
001A20  883964     MOV W4, NVMADRU
135:                       NVMADR  = ( table_offset + ( program_dword_idx * 4 ) );
001A22  78021E     MOV [W14], W4
001A24  DD22C2     SL W4, #2, W5
001A26  90026E     MOV [W14+12], W4
001A28  428204     ADD W5, W4, W4
001A2A  883954     MOV W4, NVMADR
136:                       
137:                       // Load the two double-words into the latches.
138:                       //
139:                       // Note: Write Latches are contained in Program Memory address
140:                       // 0xFA0000-0xFA0003 (i.e. 2 instructions, aka 2 double-words).
141:                       // This requires updating TBLPAG to access the latches (i.e. TBLPAG is
142:                       // the upper 8-bits for the address).
143:                       //
144:                       // Note: The first argument to __builin_tblwt* is the latch table 
145:                       // 'offset'.  Program Memory is organized in double-words; therefore an
146:                       // 'offset' value of '0' and '1' are equivalent.  That is, both of the
147:                       // following instructions access the LSW (i.e. the lower word of the
148:                       // double-word) of the 1st double-word element:
149:                       //      ->  ____builtin_tblwtl( 0 , 0 );
150:                       //      ->  ____builtin_tblwtl( 1 , 0 );
151:                       //
152:                       // Note: The Table Page register (TBLPAG) is restored to its previous
153:                       // value following modification.  This is performed as a best-practice
154:                       // to not corrupt other function's accesses using the Table Page
155:                       // register.
156:                       //
157:                       tblpag_store = TBLPAG;
001A2C  8002A4     MOV TBLPAG, W4
001A2E  980734     MOV W4, [W14+6]
158:                       TBLPAG = 0xFA;
001A30  200FA4     MOV #0xFA, W4
001A32  8802A4     MOV W4, TBLPAG
159:                       
160:                       __builtin_tblwtl( 0 , program_dword_idx );
001A34  EB0200     CLR W4
001A36  BB0A1E     TBLWTL [W14], [W4]
161:                       __builtin_tblwth( 0 , 0      );      
001A38  EB0200     CLR W4
001A3A  EB0280     CLR W5
001A3C  BB8A05     TBLWTH W5, [W4]
162:                       __builtin_tblwtl( 2 , program_dword_idx );
001A3E  200024     MOV #0x2, W4
001A40  BB0A1E     TBLWTL [W14], [W4]
163:                       __builtin_tblwth( 2 , 0      );
001A42  200024     MOV #0x2, W4
001A44  EB0280     CLR W5
001A46  BB8A05     TBLWTH W5, [W4]
164:                       
165:                       TBLPAG = tblpag_store;
001A48  90023E     MOV [W14+6], W4
001A4A  8802A4     MOV W4, TBLPAG
166:                       
167:                       // Select a Memory word program operation.
168:                       NVMCONbits.NVMOP = 0b0001;  
001A4C  803944     MOV NVMCON, W4
001A4E  A00004     BSET W4, #0
001A50  A11004     BCLR W4, #1
001A52  A12004     BCLR W4, #2
001A54  A13004     BCLR W4, #3
001A56  883944     MOV W4, NVMCON
169:                       
170:                       // Disable control flow execution.  
171:                       // - interrupts
172:                       // - watchdog timer
173:                       // - timer1
174:                       //
175:                       // This is performed to maintain expected control flow through CPU stall.
176:                       // The CPU stalls until the erase operation is finished. The CPU will 
177:                       // not execute any instructions or respond to interrupts during this time. 
178:                       // If any interrupts occur during the programming cycle, they will remain
179:                       // pending until the cycle completes.
180:                       //
181:                       __builtin_disi( 0x3FFF );
001A58  FC3FFF     DISI #0x3FFF
182:                       WDTDisable();
001A5A  070332     RCALL WDTDisable
183:                       HwTMRDisable();
001A5C  070122     RCALL HwTMRDisable
184:               
185:                       // Perform unlock sequence and initiate starting the program/erase cycle.
186:                       //
187:                       // NOTE: The CPU stalls until the erase operation is finished. The CPU will 
188:                       // not execute any instructions or respond to interrupts during this time. 
189:                       // If any interrupts occur during the programming cycle, they will remain
190:                       // pending until the cycle completes.
191:                       //
192:                       NVMKEY = 0x55;
001A5E  200554     MOV #0x55, W4
001A60  883974     MOV W4, NVMKEY
193:                       NVMKEY = 0xAA;
001A62  200AA4     MOV #0xAA, W4
001A64  883974     MOV W4, NVMKEY
194:                       NVMCONbits.WR = 1;
001A66  A8E729     BSET 0x729, #7
195:               
196:                       // Two NOP instructions are required after starting the program/erase cycle.
197:                       __builtin_nop();
001A68  000000     NOP
198:                       __builtin_nop();
001A6A  000000     NOP
199:                       
200:                       // Wait for the write cycle to be completed by the hardware
201:                       while( NVMCONbits.WR == 1 );
001A6C  000000     NOP
001A6E  803945     MOV NVMCON, W5
001A70  280004     MOV #0x8000, W4
001A72  628204     AND W5, W4, W4
001A74  520FE0     SUB W4, #0x0, [W15]
001A76  3AFFFB     BRA NZ, 0x1A6E
202:                       
203:                       // Re-enable control flow execution:
204:                       // - interrupts
205:                       // - watchdog timer
206:                       // - timer1
207:                       __builtin_disi( 0 );
001A78  FC0000     DISI #0x0
208:                       WDTEnable();
001A7A  07031F     RCALL WDTEnable
209:                       HwTMREnable();
001A7C  07010D     RCALL HwTMREnable
210:                       
211:                       // Increment the source pointer by the program row size (128 words).
212:                       // src_data_u16 += 2;
213:                       // src_idx = src_idx + 1;
214:                   }
215:                   
216:                   // Identify an NVM erase error if the hardware indicates an improper
217:                   // erase sequence attempted, or a program row underrun error occurs.
218:                   if( ( NVMCONbits.WRERR == 1 ) ||
001A88  803945     MOV NVMCON, W5
001A8A  220004     MOV #0x2000, W4
001A8C  628204     AND W5, W4, W4
001A8E  520FE0     SUB W4, #0x0, [W15]
001A90  3A0005     BRA NZ, 0x1A9C
001A98  520FE0     SUB W4, #0x0, [W15]
001A9A  320002     BRA Z, 0x1AA0
219:                       ( NVMCONbits.URERR == 1 ) )
001A92  803945     MOV NVMCON, W5
001A94  201004     MOV #0x100, W4
001A96  628204     AND W5, W4, W4
220:                   {
221:                       nvm_error = true;
001A9C  B3C014     MOV.B #0x1, W4
001A9E  984724     MOV.B W4, [W14+2]
222:                   }
223:                   
224:                   return nvm_error;
001AA0  90422E     MOV.B [W14+2], W4
225:               }
001AA2  784004     MOV.B W4, W0
001AA4  FA8000     ULNK
001AA6  060000     RETURN
226:               
227:               // *****************************************************************************
228:               // ************************** Static Functions *********************************
229:               // *****************************************************************************
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/main.c  --------------------------
1:                 ////////////////////////////////////////////////////////////////////////////////
2:                 ///
3:                 /// @file   $FILE$
4:                 /// @author $AUTHOR$
5:                 /// @date   $DATE$
6:                 /// @brief  Source code file for defining hardware operation.   
7:                 ///
8:                 ////////////////////////////////////////////////////////////////////////////////
9:                 
10:                // *****************************************************************************
11:                // ************************** System Include Files *****************************
12:                // *****************************************************************************
13:                #include <xc.h>
14:                #include <stdbool.h>
15:                #include <stddef.h>
16:                #include <stdint.h>
17:                
18:                // *****************************************************************************
19:                // ************************** User Include Files *******************************
20:                // *****************************************************************************
21:                #include "hw.h"
22:                #include "ina219.h"
23:                #include "adc.h"
24:                #include "wdt.h"
25:                #include "rst.h"
26:                #include "pwm.h"
27:                #include "can.h"
28:                #include "cfg.h"
29:                #include "nvm.h"
30:                #include "ver.h"
31:                #include "vsense.h"
32:                #include "servo.h"
33:                
34:                // *****************************************************************************
35:                // ************************** Defines ******************************************
36:                // *****************************************************************************
37:                
38:                // *****************************************************************************
39:                // ************************** Global Functions *********************************
40:                // *****************************************************************************
41:                
42:                int main ( void )
43:                {
001F88  FA0000     LNK #0x0
44:                    // Enable the watchdog timer operation.
45:                    WDTEnable();
001F8A  070097     RCALL WDTEnable
46:                    
47:                    // Initialize CPU hardware.
48:                    HwInit();
001F8C  07FE7D     RCALL HwInit
49:                    ADCInit();
001F8E  07FE07     RCALL ADCInit
50:                    PWMInit();
001F90  07FF4E     RCALL PWMInit
51:                    CANInit();
001F92  07FA7F     RCALL CANInit
52:                    NVMInit();
001F94  07FD06     RCALL NVMInit
53:                    
54:                    // Initialize peripheral hardware.
55:                    INA219Init();
001F96  07FF8B     RCALL INA219Init
56:                    
57:                    // Determine the processor reset source.
58:                    RSTStartup();
001F98  07FFC1     RCALL RSTStartup
59:                    
60:                    // Enable the hardware timer(s) to start interrupt threads of main
61:                    // processing control-flow.
62:                    HwTMREnable();
001F9A  07FE7E     RCALL HwTMREnable
63:                    PWMEnable();
001F9C  07FF7C     RCALL PWMEnable
64:                    
65:                    // Enable the Global Interrupt flag for executive control-flow.
66:                    INTCON2bits.GIE = 1;   
001F9E  A8E8C3     BSET 0x8C3, #7
67:                    
68:                    // Execute background thread infinite-loop.
69:                    while( 1 );
001FA0  37FFFF     BRA 0x1FA0
70:                    
71:                    return 0;
72:                } 
73:                
74:                void __interrupt( no_auto_psv ) _T1Interrupt ( void )
75:                {    
001FA2  F80036     PUSH RCOUNT
001FA4  BE9F80     MOV.D W0, [W15++]
001FA6  BE9F82     MOV.D W2, [W15++]
001FA8  BE9F84     MOV.D W4, [W15++]
001FAA  BE9F86     MOV.D W6, [W15++]
001FAC  FA0000     LNK #0x0
76:                    // INPUT - Aquire input signals for software cycle execution.
77:                    ADCService();
001FAE  07FE3C     RCALL ADCService
78:                    INA219Service();
001FB0  07FF89     RCALL INA219Service
79:                    
80:                    // PROCESS & OUTPUT - Perform processing and output signals for software
81:                    // cycle execution.
82:                    WDTService();
001FB2  07007F     RCALL WDTService
83:                    VsenseService();
001FB4  07F7FD     RCALL VsenseService
84:                    ServoService();
001FB6  07001B     RCALL ServoService
85:                    CfgService();
001FB8  07F6E7     RCALL CfgService
86:                    RSTService();
001FBA  07FFDC     RCALL RSTService
87:                    VerService();
001FBC  070064     RCALL VerService
88:                    
89:                    // Service the timer interrupt.
90:                    HwTMR1Service();
001FBE  07FE76     RCALL HwTMR1Service
91:                }
001FC0  FA8000     ULNK
001FC2  BE034F     MOV.D [--W15], W6
001FC4  BE024F     MOV.D [--W15], W4
001FC6  BE014F     MOV.D [--W15], W2
001FC8  BE004F     MOV.D [--W15], W0
001FCA  F90036     POP RCOUNT
001FCC  064000     RETFIE
92:                
93:                void __interrupt( no_auto_psv ) _T2Interrupt ( void )
94:                {
001FCE  F80036     PUSH RCOUNT
001FD0  BE9F80     MOV.D W0, [W15++]
001FD2  BE9F82     MOV.D W2, [W15++]
001FD4  BE9F84     MOV.D W4, [W15++]
001FD6  BE9F86     MOV.D W6, [W15++]
001FD8  FA0000     LNK #0x0
95:                    // Service the timer interrupt.
96:                    HwTMR2Service();
001FDA  07FE6C     RCALL HwTMR2Service
97:                }
001FDC  FA8000     ULNK
001FDE  BE034F     MOV.D [--W15], W6
001FE0  BE024F     MOV.D [--W15], W4
001FE2  BE014F     MOV.D [--W15], W2
001FE4  BE004F     MOV.D [--W15], W0
001FE6  F90036     POP RCOUNT
001FE8  064000     RETFIE
98:                
99:                void __interrupt( no_auto_psv ) _DefaultInterrupt ( void )
100:               {
001FEA  FA0000     LNK #0x0
101:                   // Wait in a infinite loop for a WDT reset.
102:                   while( 1 );
001FEC  37FFFF     BRA 0x1FEC
103:               }
104:               
105:               // *****************************************************************************
106:               // ************************** Static Functions *********************************
107:               // *****************************************************************************
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/ina219.c  ------------------------
1:                 ////////////////////////////////////////////////////////////////////////////////
2:                 ///
3:                 /// @file   $FILE$
4:                 /// @author $AUTHOR$
5:                 /// @date   $DATE$
6:                 /// @brief  Source code file for defining hardware operation.   
7:                 ///
8:                 ////////////////////////////////////////////////////////////////////////////////
9:                 
10:                // *****************************************************************************
11:                // ************************** System Include Files *****************************
12:                // *****************************************************************************
13:                #include <xc.h>
14:                #include <stdbool.h>
15:                #include <stddef.h>
16:                #include <stdint.h>
17:                
18:                // *****************************************************************************
19:                // ************************** User Include Files *******************************
20:                // *****************************************************************************
21:                #include "ina219.h"
22:                #include "i2c.h"
23:                
24:                // *****************************************************************************
25:                // ************************** Defines ******************************************
26:                // *****************************************************************************
27:                
28:                // INA219 slave address.
29:                //
30:                // Note: INA219 address lines A1 and A0 are electrically grounded.  This causes
31:                // the INA219 slave address to be 0b100_0000.
32:                //
33:                #define INA219_SADDR  0x40U
34:                
35:                #define INA219_REG_CFG          0x00     // Configuration Register Address
36:                #define INA219_REG_BUS_VOLT     0x02     // Bus Voltage Register Address
37:                #define INA219_REG_CURRENT      0x04     // Current Register Address
38:                #define INA219_REG_CAL          0x05     // Calibration Register Address
39:                
40:                // *****************************************************************************
41:                // ************************** Global Variable Definitions **********************
42:                // *****************************************************************************
43:                
44:                // *****************************************************************************
45:                // ************************** File-Scope Variable Definitions ******************
46:                // *****************************************************************************
47:                static uint16_t ina219_amp;
48:                static uint16_t ina219_volt;
49:                
50:                // *****************************************************************************
51:                // ************************** Function Prototypes ******************************
52:                // *****************************************************************************
53:                
54:                // *****************************************************************************
55:                // ************************** Global Functions *********************************
56:                // *****************************************************************************
57:                void INA219Init ( void )
58:                {
001EAE  FA0000     LNK #0x0
59:                    // INA219 Configuration register data definition:
60:                    //  - byte 1: Configuration register address.
61:                    //  - byte 2: Configuration register MSB value.
62:                    //  - byte 3: Configuration register LSB value.
63:                    //
64:                    // Configuration register value:
65:                    //  - RST:   bits    15, 0b0    = peripheral reset is not performed.
66:                    //  - Spare: bits    14, 0b0
67:                    //  - BRNG:  bits    13, 0b0    = 16V full scale range is used.  Measured bus voltage (i.e. Vin-) max value expected is less than 10V.
68:                    //  - PG:    bits 12-11, 0b01   = Shunt voltage range of +-80mV used. At 10A shunt current (max) the shunt voltage is 80mV.
69:                    //  - BADC   bits 10- 7, 0b1010 = Bus voltage sampled with 12-bit resolution and 4 sample averaging.  2.13ms conversion time.
70:                    //  - SADC   bits  6- 3, 0b1010 = Shunt voltage sampled with 12-bit resolution and 4 sample averaging.  2.13ms conversion time.
71:                    //  - MODE   bits  2- 0, 0b111  = Shunt voltage and Bus voltage continuously sampled.
72:                    //
73:                    // Note: With 12-bit resolution and a 16V full scale range for the bus
74:                    // voltage (Vin-), the ATD LSB is: 16V / ( 2 ^ 12 ) ~= 4mV.
75:                    //
76:                    // Note: With 12-bit resolution and 80mV positive range for the shunt
77:                    // voltage, the ATD LSB is: 80mV / ( 2 ^ 12 ) ~= 20uV.
78:                    //
79:                    static const uint8_t cfg_reg_data[] = 
80:                    {
81:                        INA219_REG_CFG,
82:                        0b00001101,
83:                        0b01010111,
84:                    };
85:                    
86:                    // INA219 Calibration register data definition:
87:                    //  - byte 1: Calibration register address.
88:                    //  - byte 2: Calibration register MSB value.
89:                    //  - byte 3: Calibration register LSB value.
90:                    //
91:                    // INA219 datasheet Calibration register calculation:
92:                    // (1) Vbus_max     = 10V
93:                    //     Vshunt_max   = 80mV
94:                    //     Rshunt       = 8mOhms
95:                    //
96:                    // (2) MaxPossible_I = 80mV / 8mOhms = 10A
97:                    //
98:                    // (3) Max_Expected_I, chosen as MaxPossible_I (10A).
99:                    //
100:                   // (4) Min_LSB = 10A / 2^15 ~= 3.0E-4
101:                   //     Max_LSB = 10A / 2^12 ~= 2.4E-3
102:                   //     Current_LSB chosen as 1mA
103:                   //
104:                   // (5) Cal = trunc( 0.04096 / ( Current_LSB * Rshunt ) ) = 5120 = 0x1400
105:                   //
106:                   static const uint8_t cal_reg_data[] = 
107:                   {
108:                       INA219_REG_CAL,
109:                       0x14,
110:                       0x00,
111:                   };
112:                   
113:                   // Program the INA219 Configuration register.
114:                   I2CWrite( INA219_SADDR, &cfg_reg_data[ 0 ], sizeof( cfg_reg_data ) );
001EB0  B3C032     MOV.B #0x3, W2
001EB2  294801     MOV #0x9480, W1
001EB4  B3C400     MOV.B #0x40, W0
001EB6  07FDF8     RCALL I2CWrite
115:                   
116:                   // Program the INA219 Calibration register.
117:                   I2CWrite( INA219_SADDR, &cal_reg_data[ 0 ], sizeof( cal_reg_data ) );    
001EB8  B3C032     MOV.B #0x3, W2
001EBA  294831     MOV #0x9483, W1
001EBC  B3C400     MOV.B #0x40, W0
001EBE  07FDF4     RCALL I2CWrite
118:               }
001EC0  FA8000     ULNK
001EC2  060000     RETURN
119:               
120:               void INA219Service ( void )
121:               {
001EC4  FA0004     LNK #0x4
122:                   static const uint8_t volt_sel_data[] = 
123:                   {
124:                       INA219_REG_BUS_VOLT,
125:                   };
126:                   
127:                   static const uint8_t amp_sel_data[] = 
128:                   {
129:                       INA219_REG_CURRENT,
130:                   };
131:                   
132:                   uint16_t volt_reg_val;
133:                   int16_t  amp_reg_val;
134:                   
135:                   // Select the Bus Voltage register for the subsequent read operation.
136:                   I2CWrite( INA219_SADDR, &volt_sel_data[ 0 ], sizeof( volt_sel_data ) );
001EC6  B3C012     MOV.B #0x1, W2
001EC8  2947E1     MOV #0x947E, W1
001ECA  B3C400     MOV.B #0x40, W0
001ECC  07FDED     RCALL I2CWrite
137:                   
138:                   // Read the Bus Voltage (Vin-) value.
139:                   I2CRead( INA219_SADDR, (uint8_t*) &volt_reg_val, sizeof ( volt_reg_val ) );
001ECE  78020E     MOV W14, W4
001ED0  B3C022     MOV.B #0x2, W2
001ED2  780084     MOV W4, W1
001ED4  B3C400     MOV.B #0x40, W0
001ED6  07FE03     RCALL I2CRead
140:                   
141:                   // 1. Remove Bus Voltage offset - within the INA219 register, the value
142:                   // is positioned at bits 14-3.
143:                   //
144:                   // 2. Scale the Bus Voltage to an LSb of 1mV.  With the peripheral's
145:                   // configuration (see initialization function), the values scaling is 
146:                   // an LSb of 4mV.  Therefore, the value need to be multiplied by 4.
147:                   //
148:                   ina219_volt = volt_reg_val >> 3;
001ED8  78021E     MOV [W14], W4
001EDA  DE2243     LSR W4, #3, W4
001EDC  88A2D4     MOV W4, ina219_volt
149:                   ina219_volt = ina219_volt  << 2;
001EDE  80A2D4     MOV ina219_volt, W4
001EE0  DD2242     SL W4, #2, W4
001EE2  88A2D4     MOV W4, ina219_volt
150:                   
151:                   // Select the Current register for the subsequent read operation.
152:                   I2CWrite( INA219_SADDR, &amp_sel_data[ 0 ], sizeof( amp_sel_data ) );
001EE4  B3C012     MOV.B #0x1, W2
001EE6  2947F1     MOV #0x947F, W1
001EE8  B3C400     MOV.B #0x40, W0
001EEA  07FDDE     RCALL I2CWrite
153:                   
154:                   // Read the Current value.
155:                   I2CRead( INA219_SADDR, (uint8_t*) &amp_reg_val, sizeof ( amp_reg_val ) );
001EEC  E8820E     INC2 W14, W4
001EEE  B3C022     MOV.B #0x2, W2
001EF0  780084     MOV W4, W1
001EF2  B3C400     MOV.B #0x40, W0
001EF4  07FDF4     RCALL I2CRead
156:                   
157:                   // Saturate current to a positive value.  The INA219 current register is a
158:                   // signed value, but negative current is not expected.
159:                   if ( amp_reg_val < 0 )
001EF6  90021E     MOV [W14+2], W4
001EF8  520FE0     SUB W4, #0x0, [W15]
001EFA  3D0002     BRA GE, 0x1F00
160:                   {
161:                       amp_reg_val = 0;
001EFC  EB0200     CLR W4
001EFE  980714     MOV W4, [W14+2]
162:                   }
163:                   
164:                   ina219_amp = amp_reg_val;
001F00  90021E     MOV [W14+2], W4
001F02  88A2C4     MOV W4, ina219_amp
165:               }
001F04  FA8000     ULNK
001F06  060000     RETURN
166:               
167:               uint16_t INA219AmpGet ( void )
168:               {
001F08  FA0000     LNK #0x0
169:                   return ina219_amp;
001F0A  80A2C4     MOV ina219_amp, W4
170:               }
001F0C  780004     MOV W4, W0
001F0E  FA8000     ULNK
001F10  060000     RETURN
171:               
172:               uint16_t INA219VoltGet ( void )
173:               {
001F12  FA0000     LNK #0x0
174:                   return ina219_volt;
001F14  80A2D4     MOV ina219_volt, W4
175:               }
001F16  780004     MOV W4, W0
001F18  FA8000     ULNK
001F1A  060000     RETURN
176:                       
177:               // *****************************************************************************
178:               // ************************** Static Functions *********************************
179:               // *****************************************************************************
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/i2c.c  ---------------------------
1:                 ////////////////////////////////////////////////////////////////////////////////
2:                 ///
3:                 /// @file   $FILE$
4:                 /// @author $AUTHOR$
5:                 /// @date   $DATE$
6:                 /// @brief  Source code file for defining hardware operation.   
7:                 ///
8:                 ////////////////////////////////////////////////////////////////////////////////
9:                 
10:                // *****************************************************************************
11:                // ************************** System Include Files *****************************
12:                // *****************************************************************************
13:                #include <xc.h>
14:                #include <stdbool.h>
15:                #include <stddef.h>
16:                #include <stdint.h>
17:                
18:                // *****************************************************************************
19:                // ************************** User Include Files *******************************
20:                // *****************************************************************************
21:                #include "i2c.h"
22:                
23:                // *****************************************************************************
24:                // ************************** Defines ******************************************
25:                // *****************************************************************************
26:                
27:                // *****************************************************************************
28:                // ************************** Global Variable Definitions **********************
29:                // *****************************************************************************
30:                
31:                // *****************************************************************************
32:                // ************************** File-Scope Variable Definitions ******************
33:                // *****************************************************************************
34:                static bool i2c_error_latch = false;
35:                
36:                // *****************************************************************************
37:                // ************************** Function Prototypes ******************************
38:                // *****************************************************************************
39:                static void     I2CStartSeq ( void );
40:                static void     I2CTxSeq    ( uint8_t tx_data );
41:                static uint8_t  I2CRxSeq    ( void );
42:                static void     I2CStopSeq  ( void );
43:                
44:                // *****************************************************************************
45:                // ************************** Global Functions *********************************
46:                // *****************************************************************************
47:                void I2CWrite( uint8_t saddr, const uint8_t* data, uint8_t data_len )
48:                {
001AA8  FA0008     LNK #0x8
001AAA  984720     MOV.B W0, [W14+2]
001AAC  980721     MOV W1, [W14+4]
001AAE  984762     MOV.B W2, [W14+6]
49:                    uint8_t data_idx;
50:                    
51:                    // Perform a start sequence.
52:                    I2CStartSeq();
001AB0  070036     RCALL _I2CStartSeq
53:                    
54:                    // Transmit the slave address and W/R byte.
55:                    //
56:                    // Note: The slave address occupies bits 7-1 of the transmitted byte.  The
57:                    // write/read command occupies bit 0 of the transmitted byte.  A write
58:                    // operation is identified by setting bit 0 as '0'.
59:                    I2CTxSeq( saddr << 1 );
001AB2  90422E     MOV.B [W14+2], W4
001AB4  424204     ADD.B W4, W4, W4
001AB6  784004     MOV.B W4, W0
001AB8  07003B     RCALL _I2CTxSeq
60:                    
61:                    // Transmit the supplied data.
62:                    for ( data_idx = 0U;
001ABA  EB4200     CLR.B W4
001ABC  784F04     MOV.B W4, [W14]
001ABE  370008     BRA 0x1AD0
001AD0  90426E     MOV.B [W14+6], W4
001AD2  78429E     MOV.B [W14], W5
001AD4  52CF84     SUB.B W5, W4, [W15]
001AD6  39FFF4     BRA NC, 0x1AC0
63:                          data_idx < data_len;
64:                          data_idx++ )
001ACE  E84F1E     INC.B [W14], [W14]
65:                    {
66:                        I2CTxSeq( data[ data_idx ] );
001AC0  78429E     MOV.B [W14], W5
001AC2  FB8205     ZE W5, W4
001AC4  9002AE     MOV [W14+4], W5
001AC6  428204     ADD W5, W4, W4
001AC8  784214     MOV.B [W4], W4
001ACA  784004     MOV.B W4, W0
001ACC  070031     RCALL _I2CTxSeq
67:                    }
68:                
69:                    // Perform a stop sequence.
70:                    I2CStopSeq();
001AD8  070059     RCALL _I2CStopSeq
71:                }
001ADA  FA8000     ULNK
001ADC  060000     RETURN
72:                
73:                void I2CRead( uint8_t saddr, uint8_t* data, uint8_t data_len )
74:                {
001ADE  FA0008     LNK #0x8
001AE0  781F88     MOV W8, [W15++]
001AE2  984720     MOV.B W0, [W14+2]
001AE4  980721     MOV W1, [W14+4]
001AE6  984762     MOV.B W2, [W14+6]
75:                    uint8_t data_idx;
76:                    
77:                    // Perform a start sequence.
78:                    I2CStartSeq();
001AE8  07001A     RCALL _I2CStartSeq
79:                    
80:                    // Transmit the slave address and W/R byte.
81:                    //
82:                    // Note: The slave address occupies bits 7-1 of the transmitted byte.  The
83:                    // write/read command occupies bit 0 of the transmitted byte.  A read
84:                    // operation is identified by setting bit 0 as '1'.
85:                    I2CTxSeq( ( saddr << 1 ) | 0b1 );
001AEA  90422E     MOV.B [W14+2], W4
001AEC  FB8204     ZE W4, W4
001AEE  420204     ADD W4, W4, W4
001AF0  784204     MOV.B W4, W4
001AF2  A00404     BSET.B W4, #0
001AF4  784004     MOV.B W4, W0
001AF6  07001C     RCALL _I2CTxSeq
86:                    
87:                    // Stored received data in the supplied buffer.
88:                    for ( data_idx = 0U;
001AF8  EB4200     CLR.B W4
001AFA  784F04     MOV.B W4, [W14]
001AFC  370008     BRA 0x1B0E
001B0E  90426E     MOV.B [W14+6], W4
001B10  78429E     MOV.B [W14], W5
001B12  52CF84     SUB.B W5, W4, [W15]
001B14  39FFF4     BRA NC, 0x1AFE
89:                          data_idx < data_len;
90:                          data_idx++ )
001B0C  E84F1E     INC.B [W14], [W14]
91:                    {
92:                        data[ data_idx ] = I2CRxSeq();
001AFE  78429E     MOV.B [W14], W5
001B00  FB8205     ZE W5, W4
001B02  9002AE     MOV [W14+4], W5
001B04  428404     ADD W5, W4, W8
001B06  07002F     RCALL _I2CRxSeq
001B08  784200     MOV.B W0, W4
001B0A  784C04     MOV.B W4, [W8]
93:                    }
94:                
95:                    // Perform a stop sequence.
96:                    I2CStopSeq();
001B16  07003A     RCALL _I2CStopSeq
97:                }
001B18  78044F     MOV [--W15], W8
001B1A  FA8000     ULNK
001B1C  060000     RETURN
98:                
99:                // *****************************************************************************
100:               // ************************** Static Functions *********************************
101:               // *****************************************************************************
102:               
103:               ////////////////////////////////////////////////////////////////////////////////
104:               /// @brief  Read data using the I2C interface.
105:               /// @param 
106:               /// @return
107:               ////////////////////////////////////////////////////////////////////////////////
108:               static void I2CStartSeq ( void )
109:               {
001B1E  FA0000     LNK #0x0
110:                   // Enable a Start sequence.
111:                   I2C1CON1bits.SEN = 1;
001B20  A80200     BSET I2C1CONL, #0
112:               
113:                   // Wait for Start sequence to complete.
114:                   while( I2C1CON1bits.SEN == 1 );
001B22  000000     NOP
001B24  801004     MOV I2C1CONL, W4
001B26  620261     AND W4, #0x1, W4
001B28  520FE0     SUB W4, #0x0, [W15]
001B2A  3AFFFC     BRA NZ, 0x1B24
115:               }
001B2C  FA8000     ULNK
001B2E  060000     RETURN
116:               
117:               ////////////////////////////////////////////////////////////////////////////////
118:               /// @brief  Read data using the I2C interface.
119:               /// @param 
120:               /// @return
121:               ////////////////////////////////////////////////////////////////////////////////
122:               static void I2CTxSeq ( uint8_t tx_data )
123:               {
001B30  FA0002     LNK #0x2
001B32  784F00     MOV.B W0, [W14]
124:                   // Write the data to the transmit register.
125:                   I2C1TRN = tx_data;
001B34  78429E     MOV.B [W14], W5
001B36  FB8205     ZE W5, W4
001B38  881064     MOV W4, I2C1TRN
126:               
127:                   // Wait for end of transmission.
128:                   //
129:                   // Note: TBF is set by the hardware when the software loads the transmit
130:                   // register (I2C1TRN).  The complexity cannot be reduced by checking 
131:                   // only the state of status bit 'TRSTAT' (to identify reception of 
132:                   // ACK/NAK) since TRSTAT is set high after SDA is updated with the first
133:                   // data byte.  That is, a delay exists between updating the transmit
134:                   // register (I2C1TRN) and status register 'TRSTAT' being '1'.
135:                   //
136:                   while( I2C1STATbits.TBF == 1 );
001B3A  000000     NOP
001B3C  801024     MOV I2C1STAT, W4
001B3E  620261     AND W4, #0x1, W4
001B40  520FE0     SUB W4, #0x0, [W15]
001B42  3AFFFC     BRA NZ, 0x1B3C
137:               
138:                   // Wait for reception of ACK/NAK.
139:                   while( I2C1STATbits.TRSTAT == 1 );
001B44  000000     NOP
001B46  801025     MOV I2C1STAT, W5
001B48  240004     MOV #0x4000, W4
001B4A  628204     AND W5, W4, W4
001B4C  520FE0     SUB W4, #0x0, [W15]
001B4E  3AFFFB     BRA NZ, 0x1B46
140:                   
141:                   // NAK is received from slave ?
142:                   if( I2C1STATbits.ACKSTAT == 1 )
001B50  801025     MOV I2C1STAT, W5
001B52  280004     MOV #0x8000, W4
001B54  628204     AND W5, W4, W4
001B56  520FE0     SUB W4, #0x0, [W15]
001B58  320004     BRA Z, 0x1B62
143:                   {
144:                       i2c_error_latch = true;
001B5A  B3C014     MOV.B #0x1, W4
001B5C  784284     MOV.B W4, W5
001B5E  214666     MOV #0x1466, W6
001B60  784B05     MOV.B W5, [W6]
145:                   }
146:               }
001B62  FA8000     ULNK
001B64  060000     RETURN
147:               
148:               ////////////////////////////////////////////////////////////////////////////////
149:               /// @brief  Read data using the I2C interface.
150:               /// @param 
151:               /// @return
152:               ////////////////////////////////////////////////////////////////////////////////
153:               static uint8_t I2CRxSeq ( void )
154:               {
001B66  FA0002     LNK #0x2
155:                   uint8_t rx_data;
156:                   
157:                   // Enable Receive sequence
158:                   I2C1CON1bits.RCEN = 1;
001B68  A86200     BSET I2C1CONL, #3
159:                   
160:                   // Wait for the data to be received.
161:                   while( I2C1STATbits.RBF == 0 );
001B6A  000000     NOP
001B6C  801024     MOV I2C1STAT, W4
001B6E  620262     AND W4, #0x2, W4
001B70  520FE0     SUB W4, #0x0, [W15]
001B72  32FFFC     BRA Z, 0x1B6C
162:                   
163:                   // Read the received data.
164:                   rx_data = I2C1RCV;
001B74  801074     MOV I2C1RCV, W4
001B76  784F04     MOV.B W4, [W14]
165:                   
166:                   // Enable an Acknowledge sequence.
167:                   I2C1CON1bits.ACKEN = 1;
001B78  A88200     BSET I2C1CONL, #4
168:                   
169:                   // Wait for the Acknowledge sequence to complete.
170:                   while( I2C1CON1bits.ACKEN == 1 );
001B7A  000000     NOP
001B7C  801004     MOV I2C1CONL, W4
001B7E  620270     AND W4, #0x10, W4
001B80  520FE0     SUB W4, #0x0, [W15]
001B82  3AFFFC     BRA NZ, 0x1B7C
171:                   
172:                   return rx_data;
001B84  78421E     MOV.B [W14], W4
173:               }
001B86  784004     MOV.B W4, W0
001B88  FA8000     ULNK
001B8A  060000     RETURN
174:               
175:               ////////////////////////////////////////////////////////////////////////////////
176:               /// @brief  Read data using the I2C interface.
177:               /// @param 
178:               /// @return
179:               ////////////////////////////////////////////////////////////////////////////////
180:               static void I2CStopSeq ( void )
181:               {
001B8C  FA0000     LNK #0x0
182:                   // Enable a Stop sequence
183:                   I2C1CON1bits.PEN = 1;
001B8E  A84200     BSET I2C1CONL, #2
184:                   
185:                   // Wait for Stop sequence to complete.
186:                   while( I2C1CON1bits.PEN == 1 );
001B90  000000     NOP
001B92  801004     MOV I2C1CONL, W4
001B94  620264     AND W4, #0x4, W4
001B96  520FE0     SUB W4, #0x0, [W15]
001B98  3AFFFC     BRA NZ, 0x1B92
187:               }
001B9A  FA8000     ULNK
001B9C  060000     RETURN
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/hw.c  ----------------------------
1:                 ////////////////////////////////////////////////////////////////////////////////
2:                 ///
3:                 /// @file   $FILE$
4:                 /// @author $AUTHOR$
5:                 /// @date   $DATE$
6:                 /// @brief  Source code file for defining hardware operation.   
7:                 ///
8:                 ////////////////////////////////////////////////////////////////////////////////
9:                 
10:                // *****************************************************************************
11:                // ************************** System Include Files *****************************
12:                // *****************************************************************************
13:                #include <xc.h>
14:                #include <stdbool.h>
15:                #include <stddef.h>
16:                #include <stdint.h>
17:                
18:                // *****************************************************************************
19:                // ************************** User Include Files *******************************
20:                // *****************************************************************************
21:                #include "hw.h"
22:                
23:                // *****************************************************************************
24:                // ************************** Defines ******************************************
25:                // *****************************************************************************
26:                
27:                // DSPIC33EV256GM102 Configuration Bit Settings
28:                
29:                // FSEC
30:                #pragma config BWRP = OFF               // Boot Segment Write-Protect Bit (Boot Segment may be written)
31:                #pragma config BSS = DISABLED           // Boot Segment Code-Protect Level bits (No Protection (other than BWRP))
32:                #pragma config BSS2 = OFF               // Boot Segment Control Bit (No Boot Segment)
33:                #pragma config GWRP = OFF               // General Segment Write-Protect Bit (General Segment may be written)
34:                #pragma config GSS = DISABLED           // General Segment Code-Protect Level bits (No Protection (other than GWRP))
35:                #pragma config CWRP = OFF               // Configuration Segment Write-Protect Bit (Configuration Segment may be written)
36:                #pragma config CSS = DISABLED           // Configuration Segment Code-Protect Level bits (No Protection (other than CWRP))
37:                #pragma config AIVTDIS = DISABLE        // Alternate Interrupt Vector Table Disable Bit  (Disable Alternate Vector Table)
38:                
39:                // FBSLIM
40:                //#pragma config BSLIM = 0x1FFF           // Boot Segment Code Flash Page Address Limit Bits (Boot Segment Flash Page Address Limit (0-0x1FFF))
41:                
42:                // FOSCSEL
43:                #pragma config FNOSC = PRIPLL           // Initial oscillator Source Selection Bits (Primary Oscillator with PLL module (XT + PLL, HS + PLL, EC + PLL))
44:                #pragma config IESO = OFF               // Two Speed Oscillator Start-Up Bit (Start up device with user selected oscillator source)
45:                
46:                // FOSC
47:                #pragma config POSCMD = EC              // Primary Oscillator Mode Select Bits (EC (External Clock) mode)
48:                #pragma config OSCIOFNC = ON            // OSC2 Pin I/O Function Enable Bit (OSC2 is general purpose digital I/O pin)
49:                #pragma config IOL1WAY = ON             // Peripheral Pin Select Configuration Bit (Allow Only One reconfiguration)
50:                #pragma config FCKSM = CSDCMD           // Clock Switching Mode Bits (Both Clock Switching and Fail-safe Clock Monitor are disabled)
51:                #pragma config PLLKEN = ON              // PLL Lock Enable Bit (Clock switch to PLL source will wait until the PLL lock signal is valid)
52:                
53:                // FWDT - Configuration Register
54:                //
55:                // WDT source is a low-power RC (LPRC) oscillator with nominal frequency 
56:                // (Flprc) of 32kHz.
57:                //
58:                // Twto := Watchdog time-out period
59:                //
60:                // Twto =   Tlprc * WDTPRE * WDTPOST
61:                //      = 31.25us *     32 *      32
62:                //      =    32ms
63:                //
64:                // Note: Flprc accuracy is +-15% (see datasheet); therefore, selection of 32ms 
65:                // nominal time-out period results in a minimum time-out period of ~27ms.
66:                //
67:                #pragma config WDTPOST = PS32    // Select WDT postscaler = 32.
68:                #pragma config WDTPRE  = PR32    // Select SDT prescaler = 32.
69:                #pragma config FWDTEN  = OFF     // Disable WDT operation. WDT enabled in software.
70:                #pragma config WINDIS  = OFF     // Operate WDT in Non-Window Mode.
71:                #pragma config WDTWIN  = WIN25   // N/A - b/c of 'WINDIS' setting.
72:                
73:                // FPOR
74:                #pragma config BOREN0 = ON              // Brown Out Reset Detection Bit (BOR is Enabled)
75:                
76:                // FICD
77:                #pragma config ICS = PGD1               // ICD Communication Channel Select Bits (Communicate on PGEC1 and PGED1)
78:                
79:                // FDMTINTVL
80:                #pragma config DMTIVTL = 0xFFFF         // Lower 16 Bits of 32 Bit DMT Window Interval (Lower 16 bits of 32 bit DMT window interval (0-0xFFFF))
81:                
82:                // FDMTINTVH
83:                #pragma config DMTIVTH = 0xFFFF         // Upper 16 Bits of 32 Bit DMT Window Interval (Upper 16 bits of 32 bit DMT window interval (0-0xFFFF))
84:                
85:                // FDMTCNTL
86:                #pragma config DMTCNTL = 0xFFFF         // Lower 16 Bits of 32 Bit DMT Instruction Count Time-Out Value (Lower 16 bits of 32 bit DMT instruction count time-out value (0-0xFFFF))
87:                
88:                // FDMTCNTH
89:                #pragma config DMTCNTH = 0xFFFF         // Upper 16 Bits of 32 Bit DMT Instruction Count Time-Out Value (Upper 16 bits of 32 bit DMT instruction count time-out value (0-0xFFFF))
90:                
91:                // FDMT
92:                #pragma config DMTEN = DISABLE          // Dead Man Timer Enable Bit (Dead Man Timer is Disabled and can be enabled by software)
93:                
94:                // FDEVOPT
95:                #pragma config PWMLOCK = ON             // PWM Lock Enable Bit (Certain PWM registers may only be written after key sequence)
96:                #pragma config ALTI2C1 = OFF            // Alternate I2C1 Pins Selection Bit (I2C1 mapped to SDA1/SCL1 pins)
97:                
98:                // FALTREG
99:                #pragma config CTXT1 = NONE             // Interrupt Priority Level (IPL) Selection Bits For Alternate Working Register Set 1 (Not Assigned)
100:               #pragma config CTXT2 = NONE             // Interrupt Priority Level (IPL) Selection Bits For Alternate Working Register Set 2 (Not Assigned)
101:               
102:               // *****************************************************************************
103:               // ************************** Function Prototypes ******************************
104:               // *****************************************************************************
105:               static void HwOSCInit  ( void );
106:               static void HwI2C1Init ( void );
107:               static void HwTMR2Init ( void );
108:               static void HwTMR1Init ( void );
109:               static void HwIOInit   ( void );
110:               
111:               // *****************************************************************************
112:               // ************************** Global Variable Definitions **********************
113:               // *****************************************************************************
114:               
115:               // *****************************************************************************
116:               // ************************** File-Scope Variable Definitions ******************
117:               // *****************************************************************************
118:               
119:               // Note: multi-threaded data.
120:               //
121:               // Note: 16-bit timer with roll-over
122:               static volatile uint16_t hwtmr_p1ms_cnt = 0;
123:               
124:               // *****************************************************************************
125:               // ************************** Global Functions *********************************
126:               // *****************************************************************************
127:               
128:               void HwInit( void )
129:               {
001C88  FA0000     LNK #0x0
130:                   HwOSCInit();
001C8A  070020     RCALL _HwOSCInit
131:                   HwTMR1Init();
001C8C  07003C     RCALL _HwTMR1Init
132:                   HwTMR2Init();
001C8E  070051     RCALL _HwTMR2Init
133:                   HwI2C1Init();
001C90  070033     RCALL _HwI2C1Init
134:                   HwIOInit();
001C92  070066     RCALL _HwIOInit
135:               }
001C94  FA8000     ULNK
001C96  060000     RETURN
136:               
137:               void HwTMREnable ( void )
138:               {
001C98  FA0000     LNK #0x0
139:                   // Enable timer 1 and timer 2.
140:                   T1CONbits.TON = 1;
001C9A  A8E105     BSET 0x105, #7
141:                   T2CONbits.TON = 1;
001C9C  A8E111     BSET 0x111, #7
142:               }
001C9E  FA8000     ULNK
001CA0  060000     RETURN
143:               
144:               void HwTMRDisable ( void )
145:               {
001CA2  FA0000     LNK #0x0
146:                   // Disable timer 1 and timer 2.
147:                   //
148:                   // Note: The timer counter value is cleared when disabling operation.
149:                   T1CONbits.TON = 0;
001CA4  A9E105     BCLR 0x105, #7
150:                   T2CONbits.TON = 0;
001CA6  A9E111     BCLR 0x111, #7
151:               }
001CA8  FA8000     ULNK
001CAA  060000     RETURN
152:               
153:               void HwTMR1Service ( void )
154:               {
001CAC  FA0000     LNK #0x0
155:                   // Clear the hardware interrupt flag.
156:                   IFS0bits.T1IF = 0; 
001CAE  A96800     BCLR IFS0, #3
157:               }
001CB0  FA8000     ULNK
001CB2  060000     RETURN
158:               
159:               void HwTMR2Service ( void )
160:               {
001CB4  FA0000     LNK #0x0
161:                   // Clear the hardware interrupt flag.
162:                   IFS0bits.T2IF = 0; 
001CB6  A9E800     BCLR IFS0, #7
163:                   
164:                   // Increment the counter (16-bit roll-over counter).
165:                   hwtmr_p1ms_cnt++;
001CB8  80A324     MOV hwtmr_p1ms_cnt, W4
001CBA  E80204     INC W4, W4
001CBC  88A324     MOV W4, hwtmr_p1ms_cnt
166:               }
001CBE  FA8000     ULNK
001CC0  060000     RETURN
167:               
168:               uint16_t HwTMRp1msGet ( void )
169:               {
001CC2  FA0000     LNK #0x0
170:                   return hwtmr_p1ms_cnt;
001CC4  80A324     MOV hwtmr_p1ms_cnt, W4
171:               }
001CC6  780004     MOV W4, W0
001CC8  FA8000     ULNK
001CCA  060000     RETURN
172:               
173:               // *****************************************************************************
174:               // ************************** Static Functions *********************************
175:               // *****************************************************************************
176:               
177:               ////////////////////////////////////////////////////////////////////////////////
178:               /// @brief  Initialize oscillator configuration.
179:               /// @param 
180:               /// @return
181:               ////////////////////////////////////////////////////////////////////////////////
182:               static void HwOSCInit( void )
183:               {
001CCC  FA0000     LNK #0x0
184:                   // Initialize the oscillator to operate the CPU clock at 40MHz
185:                   // (i.e. 20 MIPS).
186:                   // 
187:                   // M  := PLLDIV + 2
188:                   // N1 := PLLPRE + 2
189:                   // N2 := 2 * ( PLLPOST + 1)
190:                   //
191:                   // Fosc = Fin    * (  M / ( N1 * N2 ) )
192:                   //      = 10 MHz * ( 32 / (  2 *  4 ) )
193:                   //      = 40 MHz 
194:                   //
195:                   // Note: Because of the input clock source (Fin) and the requirements for
196:                   // the PLL intermediate frequencies (i.e. Fplli & Fsys), the oscillator can
197:                   // be operated in a singe mode (i.e. External Clock w/ PLL).  The PLL is
198:                   // updated to drive to the correct value before checking that the PLL is
199:                   // locked.
200:                   //
201:                   // Note: On warm-reset (i.e. not POR or BOR) the oscillator retains
202:                   // its SFR settings.  Setting of clock registers are done independent
203:                   // of the reset state to make less complex - i.e. on a warm-reset the
204:                   // clock will be set to the same value it already is (not PLL lock time
205:                   // should be needed).
206:                   //
207:                   CLKDIVbits.PLLPRE  =  0;         // PLL input divided by 2.      (N1)
001CCE  803A25     MOV CLKDIV, W5
001CD0  2FFE04     MOV #0xFFE0, W4
001CD2  628204     AND W5, W4, W4
001CD4  883A24     MOV W4, CLKDIV
208:                   CLKDIVbits.PLLPOST =  1;         // PLL output divided by 4.     (N2)
001CD6  803A24     MOV CLKDIV, W4
001CD8  A06004     BSET W4, #6
001CDA  A17004     BCLR W4, #7
001CDC  883A24     MOV W4, CLKDIV
209:                   PLLFBDbits.PLLDIV  = 30;         // PLL feedback divisor is 32.  (M)
001CDE  803A35     MOV PLLFBD, W5
001CE0  2FE004     MOV #0xFE00, W4
001CE2  628204     AND W5, W4, W4
001CE4  B301E4     IOR #0x1E, W4
001CE6  883A34     MOV W4, PLLFBD
210:                   
211:                   // Wait for the PLL to lock.
212:                   //
213:                   // Note: The PLL lock time (Tlock) is a maximum of 3.1ms (see datasheet).
214:                   //
215:                   while( OSCCONbits.LOCK == 0 );   
001CE8  000000     NOP
001CEA  803A15     MOV OSCCON, W5
001CEC  200204     MOV #0x20, W4
001CEE  628204     AND W5, W4, W4
001CF0  520FE0     SUB W4, #0x0, [W15]
001CF2  32FFFB     BRA Z, 0x1CEA
216:               }
001CF4  FA8000     ULNK
001CF6  060000     RETURN
217:               
218:               ////////////////////////////////////////////////////////////////////////////////
219:               /// @brief  Initialize I2C 1 configuration.
220:               /// @param 
221:               /// @return
222:               ////////////////////////////////////////////////////////////////////////////////
223:               static void HwI2C1Init( void )
224:               {
001CF8  FA0000     LNK #0x0
225:                   // Initialize the I2C hardware for 100KHz operation.  The hardware contains
226:                   // a single I2C module (i.e. I2C1).
227:                   //
228:                   // Fscl =    Fcy  / ( ( I2CxBRG + 2 ) * 2 )
229:                   //      =  20MHz  / ( (      98 + 2 ) * 2 )
230:                   //      = 100KHz
231:                   //
232:                   // Note: when the I2C1 module is enabled the state and direction pins
233:                   // SCL1 & SDA1 are overwritten; therefore, no pin I/O configuration
234:                   // (e.g. register ODCx) is needed.
235:                   //
236:                   // Note: Disabling of the I2C is performed before modifying register.  Out
237:                   // of reset the I2C should be disabled, so disabled is performed purely
238:                   // for robustness.
239:                   //
240:                   I2C1CON1bits.I2CEN = 0;     // Disable I2C1
001CFA  A9E201     BCLR 0x201, #7
241:                  
242:                   I2C1BRG = 98;               // Set 100 kHz clock.
001CFC  200624     MOV #0x62, W4
001CFE  881054     MOV W4, I2C1BRG
243:               
244:                   I2C1CON1bits.I2CEN = 1;     // Enable I2C1.
001D00  A8E201     BSET 0x201, #7
245:               }
001D02  FA8000     ULNK
001D04  060000     RETURN
246:               
247:               ////////////////////////////////////////////////////////////////////////////////
248:               /// @brief  Initialize Timer 1 hardware configuration.
249:               /// @param  None.
250:               /// @return None.
251:               ////////////////////////////////////////////////////////////////////////////////
252:               static void HwTMR1Init( void )
253:               {
001D06  FA0000     LNK #0x0
254:                   // Timer 1 is operated in 'Timer Mode' - the free-running timer is
255:                   // configured to trigger an interrupt ever 10ms.  This is performed to
256:                   // drive the software executive 10ms processing thread.
257:                   //
258:                   // Timer 1 is fed by the instruction/peripheral clock (Fp), see
259:                   // datasheet p. 123.
260:                   // 
261:                   // Fp       = Fosc / 2                              
262:                   //          = 20MHz
263:                   //
264:                   // Ft1int   = ( Fp    / Prescale ) / ( PR1   + 1 )
265:                   //          = ( 20Mhz / 8        ) / ( 24999 + 1 )
266:                   //          = 100Hz
267:                   //
268:                   // Note: timer configured (TSIDL) for continuous operation in idle mode.
269:                   // Idle mode is not performed by the CPU; therefore, this setting is purely 
270:                   // for robustness.
271:                   //
272:                   T1CONbits.TON   = 0;        // Disable Timer.
001D08  A9E105     BCLR 0x105, #7
273:                   T1CONbits.TCS   = 0;        // Select internal instruction cycle clock.
001D0A  A92104     BCLR T1CON, #1
274:                   T1CONbits.TGATE = 0;        // Select Timer (i.e. not Gated) mode.
001D0C  A9C104     BCLR T1CON, #6
275:                   
276:                   T1CONbits.TSIDL = 0;        // Select continuous operation in idle mode.
001D0E  A9A105     BCLR 0x105, #5
277:                   
278:                   T1CONbits.TCKPS = 0b01;     // Select prescale = 8.
001D10  800824     MOV T1CON, W4
001D12  A04004     BSET W4, #4
001D14  A15004     BCLR W4, #5
001D16  880824     MOV W4, T1CON
279:                   
280:                   TMR1            = 0;        // Clear timer value register.
001D18  EB0200     CLR W4
001D1A  880804     MOV W4, TMR1
281:                   PR1             = 24999;    // Set the period value.
001D1C  261A74     MOV #0x61A7, W4
001D1E  880814     MOV W4, PR1
282:                   
283:                   IPC0bits.T1IP   = 1;        // Select Timer 1 interrupt priority level.
001D20  804204     MOV IPC0, W4
001D22  A0C004     BSET W4, #12
001D24  A1D004     BCLR W4, #13
001D26  A1E004     BCLR W4, #14
001D28  884204     MOV W4, IPC0
284:                   IFS0bits.T1IF   = 0;        // Clear Timer 1 interrupt flag.
001D2A  A96800     BCLR IFS0, #3
285:                   IEC0bits.T1IE   = 1;        // Enable Time 1 interrupt.
001D2C  A86820     BSET IEC0, #3
286:               }
001D2E  FA8000     ULNK
001D30  060000     RETURN
287:               
288:               ////////////////////////////////////////////////////////////////////////////////
289:               /// @brief  Initialize Timer 1 hardware configuration.
290:               /// @param  None.
291:               /// @return None.
292:               ////////////////////////////////////////////////////////////////////////////////
293:               static void HwTMR2Init( void )
294:               {
001D32  FA0000     LNK #0x0
295:                   // Timer 2 is operated in 'Timer Mode' - the free-running timer is
296:                   // configured to provide a 0.1ms counter.
297:                   //
298:                   // Timer 2 is fed by the instruction/peripheral clock (Fp), see
299:                   // datasheet p. 123.
300:                   // 
301:                   // Fp       = Fosc / 2                              
302:                   //          = 20MHz
303:                   //
304:                   // Ft1int   = ( Fp    / Prescale ) / ( PR1 + 1 )
305:                   //          = ( 20Mhz / 8        ) / ( 249 + 1 )
306:                   //          = 10KHz
307:                   //
308:                   // Note: timer configured (TSIDL) for continuous operation in idle mode.
309:                   // Idle mode is not performed by the CPU; therefore, this setting is purely 
310:                   // for robustness.
311:                   //
312:                   T2CONbits.TON   = 0;        // Disable Timer.
001D34  A9E111     BCLR 0x111, #7
313:                   T2CONbits.TCS   = 0;        // Select internal instruction cycle clock.
001D36  A92110     BCLR T2CON, #1
314:                   T2CONbits.TGATE = 0;        // Select Timer (i.e. not Gated) mode.
001D38  A9C110     BCLR T2CON, #6
315:                   T2CONbits.T32   = 0;        // Select 16-bit timer.
001D3A  A96110     BCLR T2CON, #3
316:                   
317:                   T2CONbits.TSIDL = 0;        // Select continuous operation in idle mode.
001D3C  A9A111     BCLR 0x111, #5
318:                   
319:                   T2CONbits.TCKPS = 0b01;     // Select prescale = 8.
001D3E  800884     MOV T2CON, W4
001D40  A04004     BSET W4, #4
001D42  A15004     BCLR W4, #5
001D44  880884     MOV W4, T2CON
320:                   
321:                   TMR2            = 0;        // Clear timer value register.
001D46  EB0200     CLR W4
001D48  880834     MOV W4, TMR2
322:                   PR2             = 249;      // Set the period value.
001D4A  200F94     MOV #0xF9, W4
001D4C  880864     MOV W4, PR2
323:                   
324:                   IPC1bits.T2IP   = 2;        // Select Timer 2 interrupt priority level.
001D4E  804214     MOV IPC1, W4
001D50  A1C004     BCLR W4, #12
001D52  A0D004     BSET W4, #13
001D54  A1E004     BCLR W4, #14
001D56  884214     MOV W4, IPC1
325:                   IFS0bits.T2IF   = 0;        // Clear Timer 2 interrupt flag.
001D58  A9E800     BCLR IFS0, #7
326:                   IEC0bits.T2IE   = 1;        // Enable Time 2 interrupt.
001D5A  A8E820     BSET IEC0, #7
327:               }
001D5C  FA8000     ULNK
001D5E  060000     RETURN
328:               
329:               ////////////////////////////////////////////////////////////////////////////////
330:               /// @brief  Initialize discrete I/O configuration.
331:               /// @param 
332:               /// @return
333:               ////////////////////////////////////////////////////////////////////////////////
334:               static void HwIOInit( void )
335:               {
001D60  FA0000     LNK #0x0
336:                   
337:               }
001D62  FA8000     ULNK
001D64  060000     RETURN
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/cfg.c  ---------------------------
1:                 
2:                 ////////////////////////////////////////////////////////////////////////////////
3:                 ///
4:                 /// @file   $FILE$
5:                 /// @author $AUTHOR$
6:                 /// @date   $DATE$
7:                 /// @brief    
8:                 ///
9:                 ////////////////////////////////////////////////////////////////////////////////
10:                
11:                // *****************************************************************************
12:                // ************************** System Include Files *****************************
13:                // *****************************************************************************
14:                #include <xc.h>
15:                #include <stdbool.h>
16:                #include <stddef.h>
17:                #include <stdint.h>
18:                
19:                // *****************************************************************************
20:                // ************************** User Include Files *******************************
21:                // *****************************************************************************
22:                #include "cfg.h"
23:                #include "can.h"
24:                #include "nvm.h"
25:                #include "util.h"
26:                
27:                // *****************************************************************************
28:                // ************************** Defines ******************************************
29:                // *****************************************************************************
30:                
31:                // The Program Memory page is 2048 bytes (i.e. 512 program double-words) in
32:                // length.  The upper word of the 512 program double-words is not used for
33:                // constant data storage (i.e. __pack_upper_byte compiler option not used).
34:                //
35:                // The structure is defined as the size for one page (i.e. padded 
36:                // with 'reserved' bytes) so that an erase operation will not inadvertently
37:                // erase other program components.
38:                //
39:                typedef union
40:                {
41:                    struct
42:                    {
43:                        uint8_t  node_id;                                   // word  0      (note: padded)
44:                        int32_t  pwm_coeff[ CFG_PWM_COEFF_LEN ];            // word  1-12
45:                        int32_t  vsense1_coeff[ CFG_VSENSE1_COEFF_LEN ];    // word 13-24
46:                        int32_t  vsense2_coeff[ CFG_VSENSE2_COEFF_LEN ];    // word 25-36
47:                
48:                        uint16_t reserved[ 475 ];                           // word 37-512          // 987
49:                    }dstruct;
50:                    
51:                    uint16_t data_u16[ 512 ];
52:                    
53:                } CFG_DATA_U;
54:                
55:                // *****************************************************************************
56:                // ************************** Global Variable Definitions **********************
57:                // *****************************************************************************
58:                
59:                // *****************************************************************************
60:                // ************************** File-Scope Variable Definitions ******************
61:                // *****************************************************************************
62:                
63:                // Align the configuration data memory allocation to a Program Memory page.
64:                static const CFG_DATA_U __align( 1024 ) cfg_data =
65:                {
66:                    {
67:                        0x7F,       // Initialize node_id to maximum 7-bit value.
68:                        { 0x76543210 },                                                             // DEGUG CODE TEMP VALUE, SHOULD INITIALIZE TO ZERO ORDER POLYNOMIAL WITH CONSTANT VALUE OF 1.
69:                        { 0xFEDCBA98 },                                                             // DEGUG CODE TEMP VALUE, SHOULD INITIALIZE TO ZERO ORDER POLYNOMIAL WITH CONSTANT VALUE OF 1.
70:                        { 0x11223344 },                                                             // DEGUG CODE TEMP VALUE, SHOULD INITIALIZE TO ZERO ORDER POLYNOMIAL WITH CONSTANT VALUE OF 1.
71:                        { 0x5566 },                                                                 // DEGUG CODE TEMP VALUE, SHOULD INITIALIZE TO ZEROS.
72:                    }
73:                };
74:                
75:                // *****************************************************************************
76:                // ************************** Function Prototypes ******************************
77:                // *****************************************************************************
78:                static void CfgWrite ( void );
79:                static void CfgRead ( void );
80:                
81:                // *****************************************************************************
82:                // ************************** Global Functions *********************************
83:                // *****************************************************************************
84:                void CfgService ( void )
85:                {
000D88  FA0000     LNK #0x0
86:                    // Service a write request.
87:                    CfgWrite();
000D8A  070052     RCALL _CfgWrite
88:                    
89:                    // Service a read request.
90:                    CfgRead();
000D8C  0700C1     RCALL _CfgRead
91:                }
000D8E  FA8000     ULNK
000D90  060000     RETURN
92:                
93:                uint8_t CfgNodeIdGet ( void )
94:                {
000D92  FA0000     LNK #0x0
95:                    return cfg_data.dstruct.node_id;
000D94  290004     MOV #0x9000, W4
000D96  784214     MOV.B [W4], W4
96:                }
000D98  784004     MOV.B W4, W0
000D9A  FA8000     ULNK
000D9C  060000     RETURN
97:                
98:                void CfgPWMCoeffGet ( int32_t pwm_coeff[ CFG_PWM_COEFF_LEN ] )
99:                {
000D9E  FA0004     LNK #0x4
000DA0  980710     MOV W0, [W14+2]
100:                   uint8_t coeff_idx;
101:                   
102:                   for ( coeff_idx = 0;
000DA2  EB4200     CLR.B W4
000DA4  784F04     MOV.B W4, [W14]
000DA6  37000E     BRA 0xDC4
000DC4  78421E     MOV.B [W14], W4
000DC6  524FE5     SUB.B W4, #0x5, [W15]
000DC8  36FFEF     BRA LEU, 0xDA8
103:                         coeff_idx < CFG_PWM_COEFF_LEN;
104:                         coeff_idx++ )
000DC2  E84F1E     INC.B [W14], [W14]
105:                   {
106:                       pwm_coeff[ coeff_idx ] = cfg_data.dstruct.pwm_coeff[ coeff_idx ];
000DA8  78429E     MOV.B [W14], W5
000DAA  FB8205     ZE W5, W4
000DAC  DD2242     SL W4, #2, W4
000DAE  90029E     MOV [W14+2], W5
000DB0  428304     ADD W5, W4, W6
000DB2  78429E     MOV.B [W14], W5
000DB4  FB8205     ZE W5, W4
000DB6  DD2242     SL W4, #2, W4
000DB8  E88284     INC2 W4, W5
000DBA  290004     MOV #0x9000, W4
000DBC  428204     ADD W5, W4, W4
000DBE  BE0214     MOV.D [W4], W4
000DC0  BE8B04     MOV.D W4, [W6]
107:                   }
108:               }
000DCA  FA8000     ULNK
000DCC  060000     RETURN
109:               
110:               void CfgVsense1CoeffGet ( int32_t vsense1_coeff[ CFG_VSENSE1_COEFF_LEN ] )
111:               {
000DCE  FA0004     LNK #0x4
000DD0  980710     MOV W0, [W14+2]
112:                   uint8_t coeff_idx;
113:                   
114:                   for ( coeff_idx = 0;
000DD2  EB4200     CLR.B W4
000DD4  784F04     MOV.B W4, [W14]
000DD6  37000E     BRA 0xDF4
000DF4  78421E     MOV.B [W14], W4
000DF6  524FE5     SUB.B W4, #0x5, [W15]
000DF8  36FFEF     BRA LEU, 0xDD8
115:                         coeff_idx < CFG_VSENSE1_COEFF_LEN;
116:                         coeff_idx++ )
000DF2  E84F1E     INC.B [W14], [W14]
117:                   {
118:                       vsense1_coeff[ coeff_idx ] = cfg_data.dstruct.vsense1_coeff[ coeff_idx ];
000DD8  78429E     MOV.B [W14], W5
000DDA  FB8205     ZE W5, W4
000DDC  DD2242     SL W4, #2, W4
000DDE  90029E     MOV [W14+2], W5
000DE0  428304     ADD W5, W4, W6
000DE2  78429E     MOV.B [W14], W5
000DE4  FB8205     ZE W5, W4
000DE6  DD2242     SL W4, #2, W4
000DE8  4202FA     ADD W4, #0x1A, W5
000DEA  290004     MOV #0x9000, W4
000DEC  428204     ADD W5, W4, W4
000DEE  BE0214     MOV.D [W4], W4
000DF0  BE8B04     MOV.D W4, [W6]
119:                   }
120:               }
000DFA  FA8000     ULNK
000DFC  060000     RETURN
121:               
122:               void CfgVsense2CoeffGet ( int32_t vsense2_coeff[ CFG_VSENSE2_COEFF_LEN ] )
123:               {
000DFE  FA0004     LNK #0x4
000E00  980710     MOV W0, [W14+2]
124:                   uint8_t coeff_idx;
125:                   
126:                   for ( coeff_idx = 0;
000E02  EB4200     CLR.B W4
000E04  784F04     MOV.B W4, [W14]
000E06  37000F     BRA 0xE26
000E26  78421E     MOV.B [W14], W4
000E28  524FE5     SUB.B W4, #0x5, [W15]
000E2A  36FFEE     BRA LEU, 0xE08
127:                         coeff_idx < CFG_VSENSE2_COEFF_LEN;
128:                         coeff_idx++ )
000E24  E84F1E     INC.B [W14], [W14]
129:                   {
130:                       vsense2_coeff[ coeff_idx ] = cfg_data.dstruct.vsense2_coeff[ coeff_idx ];
000E08  78429E     MOV.B [W14], W5
000E0A  FB8205     ZE W5, W4
000E0C  DD2242     SL W4, #2, W4
000E0E  90029E     MOV [W14+2], W5
000E10  428304     ADD W5, W4, W6
000E12  78429E     MOV.B [W14], W5
000E14  FB8205     ZE W5, W4
000E16  DD2242     SL W4, #2, W4
000E18  200325     MOV #0x32, W5
000E1A  428284     ADD W5, W4, W5
000E1C  290004     MOV #0x9000, W4
000E1E  428204     ADD W5, W4, W4
000E20  BE0214     MOV.D [W4], W4
000E22  BE8B04     MOV.D W4, [W6]
131:                   }
132:               }
000E2C  FA8000     ULNK
000E2E  060000     RETURN
133:               
134:               // *****************************************************************************
135:               // ************************** Static Functions *********************************
136:               // *****************************************************************************
137:               
138:               ////////////////////////////////////////////////////////////////////////////////
139:               /// @brief 
140:               /// @param 
141:               /// @return
142:               ////////////////////////////////////////////////////////////////////////////////
143:               static void CfgWrite ( void )
144:               {
000E30  FA0014     LNK #0x14
145:                   static CFG_DATA_U cfg_data_cpy;
146:                   
147:                   CAN_TX_WRITE_REQ_U  write_req_payload;
148:                   CAN_TX_WRITE_RESP_U write_resp_payload;
149:                           
150:                   bool node_id_update = false;
000E32  EB4200     CLR.B W4
000E34  784F04     MOV.B W4, [W14]
151:                   
152:                   bool payload_valid;
153:                   bool fault_status;
154:                   
155:                   payload_valid = CANRxGet ( CAN_RX_MSG_CFG_WRITE_REQ, write_req_payload.data_u16 );
000E36  470264     ADD W14, #0x4, W4
000E38  780084     MOV W4, W1
000E3A  200010     MOV #0x1, W0
000E3C  0704B2     RCALL CANRxGet
000E3E  784200     MOV.B W0, W4
000E40  984724     MOV.B W4, [W14+2]
156:                   
157:                   // Write request message received ?
158:                   if( payload_valid == true )
000E42  90422E     MOV.B [W14+2], W4
000E44  524FE0     SUB.B W4, #0x0, [W15]
000E46  320062     BRA Z, 0xF0C
159:                   {
160:                       // Copy the configuration data from NVM to RAM.
161:                       cfg_data_cpy.dstruct = cfg_data.dstruct;
000E48  210504     MOV #0x1050, W4
000E4A  290005     MOV #0x9000, W5
000E4C  0901FF     REPEAT #0x1FF
000E4E  781A35     MOV [W5++], [W4++]
162:                       // cfg_data_cpy = cfg_data;
163:                       
164:                       // Update the selected fields in RAM with the new value.
165:                       switch( write_req_payload.cfg_sel )
000E50  90022E     MOV [W14+4], W4
000E52  200005     MOV #0x0, W5
000E54  200126     MOV #0x12, W6
000E56  200007     MOV #0x0, W7
000E58  520F86     SUB W4, W6, [W15]
000E5A  5A8F87     SUBB W5, W7, [W15]
000E5C  3E0036     BRA GTU, 0xECA
000E5E  010604     BRA W4
000E60  370012     BRA 0xE86
000E62  370018     BRA 0xE94
000E64  370017     BRA 0xE94
000E66  370016     BRA 0xE94
000E68  370015     BRA 0xE94
000E6A  370014     BRA 0xE94
000E6C  370013     BRA 0xE94
000E6E  37001B     BRA 0xEA6
000E70  37001A     BRA 0xEA6
000E72  370019     BRA 0xEA6
000E74  370018     BRA 0xEA6
000E76  370017     BRA 0xEA6
000E78  370016     BRA 0xEA6
000E7A  37001E     BRA 0xEB8
000E7C  37001D     BRA 0xEB8
000E7E  37001C     BRA 0xEB8
000E80  37001B     BRA 0xEB8
000E82  37001A     BRA 0xEB8
000E84  370019     BRA 0xEB8
166:                       {
167:                           case 0:
168:                               cfg_data_cpy.dstruct.node_id = write_req_payload.cfg_val_u8;
000E86  90426E     MOV.B [W14+6], W4
000E88  784284     MOV.B W4, W5
000E8A  210506     MOV #0x1050, W6
000E8C  784B05     MOV.B W5, [W6]
169:                               node_id_update =  true;
000E8E  B3C014     MOV.B #0x1, W4
000E90  784F04     MOV.B W4, [W14]
170:                               break;
000E92  37001B     BRA 0xECA
171:                               
172:                           case 1:
173:                           case 2:
174:                           case 3:
175:                           case 4:
176:                           case 5:
177:                           case 6:
178:                               cfg_data_cpy.dstruct.pwm_coeff[ write_req_payload.cfg_sel - 1 ] = write_req_payload.cfg_val_i32;
000E94  90022E     MOV [W14+4], W4
000E96  E90304     DEC W4, W6
000E98  90023E     MOV [W14+6], W4
000E9A  9002CE     MOV [W14+8], W5
000E9C  DD33C2     SL W6, #2, W7
000E9E  210526     MOV #0x1052, W6
000EA0  438306     ADD W7, W6, W6
000EA2  BE8B04     MOV.D W4, [W6]
179:                               break;
000EA4  370012     BRA 0xECA
180:                           
181:                           case 7:
182:                           case 8:
183:                           case 9:
184:                           case 10:
185:                           case 11:
186:                           case 12:
187:                               cfg_data_cpy.dstruct.vsense1_coeff[ write_req_payload.cfg_sel - 7 ] = write_req_payload.cfg_val_i32;
000EA6  90022E     MOV [W14+4], W4
000EA8  520367     SUB W4, #0x7, W6
000EAA  90023E     MOV [W14+6], W4
000EAC  9002CE     MOV [W14+8], W5
000EAE  DD33C2     SL W6, #2, W7
000EB0  2106A6     MOV #0x106A, W6
000EB2  438306     ADD W7, W6, W6
000EB4  BE8B04     MOV.D W4, [W6]
188:                               break;
000EB6  370009     BRA 0xECA
189:                           
190:                           case 13:
191:                           case 14:
192:                           case 15:
193:                           case 16:
194:                           case 17:
195:                           case 18:
196:                               cfg_data_cpy.dstruct.vsense1_coeff[ write_req_payload.cfg_sel - 13 ] = write_req_payload.cfg_val_i32;
000EB8  90022E     MOV [W14+4], W4
000EBA  52036D     SUB W4, #0xD, W6
000EBC  90023E     MOV [W14+6], W4
000EBE  9002CE     MOV [W14+8], W5
000EC0  DD33C2     SL W6, #2, W7
000EC2  2106A6     MOV #0x106A, W6
000EC4  438306     ADD W7, W6, W6
000EC6  BE8B04     MOV.D W4, [W6]
197:                               break;
000EC8  000000     NOP
198:                           
199:                           default:
200:                               ;
201:                       }
202:                       
203:                       // Erase the NVM page.
204:                       fault_status = NVMErasePage( __builtin_tblpage(   &cfg_data ), 
000ECA  210005     MOV #0x1000, W5
000ECC  201004     MOV #0x100, W4
000ECE  780085     MOV W5, W1
000ED0  780004     MOV W4, W0
000ED2  07056D     RCALL NVMErasePage
000ED4  784200     MOV.B W0, W4
000ED6  984714     MOV.B W4, [W14+1]
205:                                                    __builtin_tbloffset( &cfg_data ) );
206:                       
207:                       // Erase operation was successful ?
208:                       if( fault_status == false )
000ED8  90421E     MOV.B [W14+1], W4
000EDA  A20404     BTG.B W4, #0
000EDC  524FE0     SUB.B W4, #0x0, [W15]
000EDE  320008     BRA Z, 0xEF0
209:                       {
210:                           // Program the updated RAM copy to the NVM page.
211:                           fault_status = NVMProgramPage( cfg_data_cpy.data_u16, 
000EE0  210005     MOV #0x1000, W5
000EE2  201004     MOV #0x100, W4
000EE4  780105     MOV W5, W2
000EE6  780084     MOV W4, W1
000EE8  210500     MOV #0x1050, W0
000EEA  07058E     RCALL NVMProgramPage
000EEC  784200     MOV.B W0, W4
000EEE  984714     MOV.B W4, [W14+1]
212:                                                         __builtin_tblpage(   &cfg_data ), 
213:                                                         __builtin_tbloffset( &cfg_data ) );
214:                       }
215:                       
216:                       // Construct the Write Response message
217:                       write_resp_payload.cfg_sel      = write_resp_payload.cfg_sel;
000EF0  90026E     MOV [W14+12], W4
000EF2  980764     MOV W4, [W14+12]
218:                       write_resp_payload.fault_status = fault_status;
000EF4  90421E     MOV.B [W14+1], W4
000EF6  FB8204     ZE W4, W4
000EF8  980774     MOV W4, [W14+14]
219:                       
220:                       // Send the Write Response message.
221:                       CANTxSet ( CAN_TX_MSG_CFG_WRITE_RESP, write_resp_payload.data_u16 );
000EFA  47026C     ADD W14, #0xC, W4
000EFC  780084     MOV W4, W1
000EFE  200040     MOV #0x4, W0
000F00  0703FD     RCALL CANTxSet
222:                       
223:                       // Node ID was updated ?
224:                       if( node_id_update == true )
000F02  78421E     MOV.B [W14], W4
000F04  524FE0     SUB.B W4, #0x0, [W15]
000F06  320002     BRA Z, 0xF0C
225:                       {
226:                           // Wait for 5ms so the Write Response CAN message has time
227:                           // to be transmitted.
228:                           UtilDelay( 5 );
000F08  200050     MOV #0x5, W0
000F0A  07075D     RCALL UtilDelay
229:                           
230:                           // Perform a software reset so that the updated Node ID can
231:                           // be used for CAN message filtering.
232:                           // __asm__ volatile ("reset");                                      DEBUGGING: TEMPERARILY REMOVED
233:                       }
234:                   }
235:               }
000F0C  FA8000     ULNK
000F0E  060000     RETURN
236:               
237:               ////////////////////////////////////////////////////////////////////////////////
238:               /// @brief 
239:               /// @param 
240:               /// @return
241:               ////////////////////////////////////////////////////////////////////////////////
242:               static void CfgRead ( void )
243:               {
000F10  FA0012     LNK #0x12
244:                   CAN_TX_READ_REQ_U   read_req_payload;      
245:                   CAN_TX_READ_RESP_U  read_resp_payload;
246:               
247:                   bool payload_valid;
248:                   
249:                   payload_valid = CANRxGet ( CAN_RX_MSG_CFG_READ_REQ, read_req_payload.data_u16 );
000F12  E8820E     INC2 W14, W4
000F14  780084     MOV W4, W1
000F16  200020     MOV #0x2, W0
000F18  070444     RCALL CANRxGet
000F1A  784200     MOV.B W0, W4
000F1C  784F04     MOV.B W4, [W14]
250:                   
251:                   // Read request message received ?
252:                   if( payload_valid == true )
000F1E  78421E     MOV.B [W14], W4
000F20  524FE0     SUB.B W4, #0x0, [W15]
000F22  320044     BRA Z, 0xFAC
253:                   {
254:                       // Copy the configuration selection to the response message.
255:                       read_resp_payload.cfg_sel = read_req_payload.cfg_sel;
000F24  90021E     MOV [W14+2], W4
000F26  980754     MOV W4, [W14+10]
256:                       
257:                       // Depending on the configuration selection, populate the required
258:                       // data within the response message.
259:                       switch( read_resp_payload.cfg_sel )
000F28  90025E     MOV [W14+10], W4
000F2A  200005     MOV #0x0, W5
000F2C  200126     MOV #0x12, W6
000F2E  200007     MOV #0x0, W7
000F30  520F86     SUB W4, W6, [W15]
000F32  5A8F87     SUBB W5, W7, [W15]
000F34  3E0037     BRA GTU, 0xFA4
000F36  010604     BRA W4
000F38  370012     BRA 0xF5E
000F3A  370015     BRA 0xF66
000F3C  370014     BRA 0xF66
000F3E  370013     BRA 0xF66
000F40  370012     BRA 0xF66
000F42  370011     BRA 0xF66
000F44  370010     BRA 0xF66
000F46  370019     BRA 0xF7A
000F48  370018     BRA 0xF7A
000F4A  370017     BRA 0xF7A
000F4C  370016     BRA 0xF7A
000F4E  370015     BRA 0xF7A
000F50  370014     BRA 0xF7A
000F52  37001D     BRA 0xF8E
000F54  37001C     BRA 0xF8E
000F56  37001B     BRA 0xF8E
000F58  37001A     BRA 0xF8E
000F5A  370019     BRA 0xF8E
000F5C  370018     BRA 0xF8E
260:                       {
261:                           case 0:
262:                               read_resp_payload.cfg_val_u8 = cfg_data.dstruct.node_id;
000F5E  290004     MOV #0x9000, W4
000F60  784214     MOV.B [W4], W4
000F62  984F44     MOV.B W4, [W14+12]
263:                               break;
000F64  37001F     BRA 0xFA4
264:                               
265:                           case 1:
266:                           case 2:
267:                           case 3:
268:                           case 4:
269:                           case 5:
270:                           case 6:
271:                               read_resp_payload.cfg_val_i32 = cfg_data.dstruct.pwm_coeff[ read_resp_payload.cfg_sel - 1 ];
000F66  90025E     MOV [W14+10], W4
000F68  E90204     DEC W4, W4
000F6A  DD2242     SL W4, #2, W4
000F6C  E88284     INC2 W4, W5
000F6E  290004     MOV #0x9000, W4
000F70  428204     ADD W5, W4, W4
000F72  BE0214     MOV.D [W4], W4
000F74  980764     MOV W4, [W14+12]
000F76  980775     MOV W5, [W14+14]
272:                               break;
000F78  370015     BRA 0xFA4
273:                           
274:                           case 7:
275:                           case 8:
276:                           case 9:
277:                           case 10:
278:                           case 11:
279:                           case 12:
280:                               read_resp_payload.cfg_val_i32 = cfg_data.dstruct.vsense1_coeff[ read_resp_payload.cfg_sel - 7 ];
000F7A  90025E     MOV [W14+10], W4
000F7C  520267     SUB W4, #0x7, W4
000F7E  DD2242     SL W4, #2, W4
000F80  4202FA     ADD W4, #0x1A, W5
000F82  290004     MOV #0x9000, W4
000F84  428204     ADD W5, W4, W4
000F86  BE0214     MOV.D [W4], W4
000F88  980764     MOV W4, [W14+12]
000F8A  980775     MOV W5, [W14+14]
281:                               break;
000F8C  37000B     BRA 0xFA4
282:                           
283:                           case 13:
284:                           case 14:
285:                           case 15:
286:                           case 16:
287:                           case 17:
288:                           case 18:
289:                               read_resp_payload.cfg_val_i32 = cfg_data.dstruct.vsense2_coeff[ read_resp_payload.cfg_sel - 13 ];
000F8E  90025E     MOV [W14+10], W4
000F90  52026D     SUB W4, #0xD, W4
000F92  DD2242     SL W4, #2, W4
000F94  200325     MOV #0x32, W5
000F96  428284     ADD W5, W4, W5
000F98  290004     MOV #0x9000, W4
000F9A  428204     ADD W5, W4, W4
000F9C  BE0214     MOV.D [W4], W4
000F9E  980764     MOV W4, [W14+12]
000FA0  980775     MOV W5, [W14+14]
290:                               break;
000FA2  000000     NOP
291:                           
292:                           default:
293:                               ;
294:                       }
295:                       
296:                       // Send the Read Response message.
297:                       CANTxSet ( CAN_TX_MSG_CFG_READ_RESP, read_resp_payload.data_u16 );
000FA4  47026A     ADD W14, #0xA, W4
000FA6  780084     MOV W4, W1
000FA8  200050     MOV #0x5, W0
000FAA  0703A8     RCALL CANTxSet
298:                   }
299:               }
000FAC  FA8000     ULNK
000FAE  060000     RETURN
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/can.c  ---------------------------
1:                 
2:                 ////////////////////////////////////////////////////////////////////////////////
3:                 ///
4:                 /// @file   $FILE$
5:                 /// @author $AUTHOR$
6:                 /// @date   $DATE$
7:                 /// @brief  Source code file for defining hardware operation.   
8:                 ///
9:                 ////////////////////////////////////////////////////////////////////////////////
10:                
11:                // *****************************************************************************
12:                // ************************** System Include Files *****************************
13:                // *****************************************************************************
14:                #include <xc.h>
15:                #include <stdbool.h>
16:                #include <stddef.h>
17:                #include <stdint.h>
18:                
19:                // *****************************************************************************
20:                // ************************** User Include Files *******************************
21:                // *****************************************************************************
22:                #include "can.h"
23:                #include "cfg.h"
24:                
25:                // *****************************************************************************
26:                // ************************** Defines ******************************************
27:                // *****************************************************************************
28:                
29:                // *****************************************************************************
30:                // ************************** Global Variable Definitions **********************
31:                // *****************************************************************************
32:                
33:                // *****************************************************************************
34:                // ************************** File-Scope Variable Definitions ******************
35:                // *****************************************************************************
36:                static uint16_t __align( 16 * 16 ) can_msg_buf[ 16 ][ 8 ];
37:                
38:                // *****************************************************************************
39:                // ************************** Function Prototypes ******************************
40:                // *****************************************************************************
41:                static void CANTxBuildHeader ( CAN_TX_MSG_TYPE_E tx_msg_type, uint16_t msg_buf[ 8 ] );
42:                
43:                // *****************************************************************************
44:                // ************************** Global Functions *********************************
45:                // *****************************************************************************
46:                void CANInit ( void )
47:                {
001492  000000     NOP
48:                    uint8_t node_id;
49:                    
50:                    // Get the node ID - used for filtering received messages for those which
51:                    // are only applicable to the node.
52:                    node_id = CfgNodeIdGet();
001494  000024     NOP
001496  080000     DO #0, 0x16A2
001498  000104     NOP
53:                    
54:                    RPINR26bits.C1RXR = 0b0010100;  // Assign C1RX peripheral pin to RP20.
00149A  000104     NOP
00149C  000104     NOP
00149E  000145     NOP
0014A0  000000     NOP
55:                    RPOR1bits.RP36R   = 0b001110;   // Assign C1TX peripheral pint to RP36.
0014A2  000100     NOP
0014A4  000000     NOP
0014A6  400000     ADD W0, W0, W0
0014A8  001020     NOP
0014AA  000100     NOP
56:                    
57:                    C1CTRL1bits.WIN = 0; // Select the control and status registers for visibility in SFRs.
0014AC  000000     NOP
58:                    
59:                    // Request Configuration Mode for the ECAN module.
60:                    //
61:                    // Note: Configuration Mode is the state out of reset.  Configuration Mode
62:                    // is requested for robustness.
63:                    //
64:                    C1CTRL1bits.REQOP = 4;
0014AE  000000     NOP
0014B0  000004     NOP
0014B2  000000     NOP
0014B4  000004     NOP
0014B6  000004     NOP
65:                    
66:                    // Wait for the ECAN module to enter into Configuration Mode
67:                    while(C1CTRL1bits.OPMODE != 4);
0014B8  004000     NOP
0014BA  000004     NOP
0014BC  001004     NOP
0014BE  000004     NOP
0014C0  040000     GOTO 0x0
0014C2  000100     NOP
0014C4  000130     NOP
68:                
69:                    C1CTRL1bits.CSIDL   = 0;        // N/A, b/c CPU idle mode is never entered.
0014C6  000101     NOP
70:                    C1CTRL1bits.CANCKS  = 0;        // Select Fcan = Fp. 
0014C8  000000     NOP
71:                    C1CTRL1bits.CANCAP  = 0;        // CAN message timestamping not used.
0014CA  400000     ADD W0, W0, W0
72:                    
73:                    C1CTRL2bits.DNCNT   = 0;        // Disable DeviceNet feature since CAN Specification 2.0A protocol is not used.
0014CC  000011     NOP
0014CE  010000     CALL W0
0014D0  000004     NOP
0014D2  000004     NOP
74:                    
75:                    C1FCTRLbits.DMABS   = 0b100;    // 16 buffers in RAM.
0014D4  002034     NOP
0014D6  000004     NOP
0014D8  004004     NOP
0014DA  000004     NOP
0014DC  000074     NOP
76:                    C1FCTRLbits.FSA     = 0;        // N/A, FIFO not used.
0014DE  000035     NOP
0014E0  200000     MOV #0x0, W0
0014E2  000000     NOP
0014E4  000030     NOP
77:                    
78:                    C1INTEbits.IVRIE    = 0;        // Invalid Message Interrupt is disabled.
0014E6  000008     NOP
79:                    C1INTEbits.WAKIE    = 0;        // Bus Wake-up Activity Interrupt is disabled.
0014E8  004008     NOP
80:                    C1INTEbits.ERRIE    = 0;        // Error Interrupt is disabled.
0014EA  000008     NOP
81:                    C1INTEbits.FIFOIE   = 0;        // FIFO Almost Full Interrupt is disabled.
0014EC  000008     NOP
82:                    C1INTEbits.RBOVIE   = 0;        // RX Buffer Overflow Interrupt is disabled.
0014EE  000008     NOP
83:                    C1INTEbits.RBIE     = 0;        // RX Buffer Interrupt is disabled.
0014F0  00000C     NOP
84:                    C1INTEbits.TBIE     = 0;        // TX Buffer Interrupt is disabled.
0014F2  00010C     NOP
85:                    
86:                    // Fp    = 20MHz
87:                    // Fbaud = 1Mbps
88:                    //
89:                    // Ftq := Time Quantum Frequency (selected as 10MHz - i.e. 10 TQ per bit)
90:                    //
91:                    // BPR = ( Fp    / ( 2 * Ftq   ) ) - 1
92:                    //     = ( 20MHz / ( 2 * 10MHz ) ) - 1
93:                    //     = 0
94:                    //
95:                    // Synch Segment     = 1 TQ (constant)
96:                    // Propagation Delay = 3 TQ
97:                    // Phase Segment 1   = 3 TQ
98:                    // Phase Segment 2   = 3 TQ
99:                    // SJW               = Min( 4, Prop, PS1, PS2 ) = 3 TQ
100:                   //
101:                   C1CFG1bits.SJW      = 2;    // Select SJW (2 = 3 TQ).
0014F4  010004     CALL W4
0014F6  000004     NOP
0014F8  000804     NOP
0014FA  000004     NOP
102:                   C1CFG1bits.BRP      = 0;    // Select baud rate for expected Ftq.
0014FC  000405     NOP
0014FE  000004     NOP
001500  000000     NOP
001502  000080     NOP
103:                   
104:                   C1CFG2bits.WAKFIL   = 0;    // N/A, b/c sleep mode not used.
001504  000001     NOP
105:                   C1CFG2bits.SEG2PH   = 2;    // Select phase segment 2 time (2 = 3 TQ).
001506  200000     MOV #0x0, W0
001508  000000     NOP
00150A  000000     NOP
00150C  020000     CALL 0x0
00150E  000000     NOP
106:                   C1CFG2bits.SEG2PHTS = 1;    // Phase segment 2 set to be programmable.
001510  000000     NOP
107:                   C1CFG2bits.SAM      = 1;    // Select three samplings at sample point.
001512  000010     NOP
108:                   C1CFG2bits.SEG1PH   = 2;    // Select phase segment 1 time (2 = 3 TQ).
001514  000804     NOP
001516  000004     NOP
001518  040004     GOTO 0x40004
00151A  000004     NOP
00151C  000004     NOP
109:                   C1CFG2bits.PRSEG    = 2;    // Select propagation time (2 = 3 TQ).
00151E  000004     NOP
001520  000000     NOP
001522  000000     NOP
001524  000000     NOP
001526  000000     NOP
110:                   
111:                   // Setup pointers for transmit buffers and priority levels.
112:                   //
113:                   C1TR01CONbits.TXEN0     = 1;    // Buffer TRB0 is a transmit buffer.
001528  400000     ADD W0, W0, W0
114:                   C1TR01CONbits.TX0PRI    = 0b11; // Buffer TRB0 is highest priority.
00152A  000100     NOP
00152C  000000     NOP
00152E  000080     NOP
001530  000104     NOP
115:                   
116:                   C1TR01CONbits.TXEN1     = 1;    // Buffer TRB1 is a transmit buffer.
001532  000000     NOP
117:                   C1TR01CONbits.TX1PRI    = 0b11; // Buffer TRB1 is highest priority.
001534  000104     NOP
001536  000004     NOP
001538  000004     NOP
00153A  000106     NOP
118:                   
119:                   C1TR23CONbits.TXEN2     = 1;    // Buffer TRB2 is a transmit buffer.
00153C  010002     CALL W2
120:                   C1TR23CONbits.TX2PRI    = 0b01; // Buffer TRB2 is low intermediate priority.
00153E  000104     NOP
001540  000000     NOP
001542  000100     NOP
001544  000130     NOP
121:                   
122:                   C1TR23CONbits.TXEN3     = 1;    // Buffer TRB3 is a transmit buffer.
001546  000011     NOP
123:                   C1TR23CONbits.TX3PRI    = 0b01; // Buffer TRB3 is low intermediate priority.
001548  000110     NOP
00154A  040000     GOTO 0x0
00154C  000000     NOP
00154E  000110     NOP
124:                   
125:                   C1TR45CONbits.TXEN4     = 1;    // Buffer TRB4 is a transmit buffer.
001550  000014     NOP
126:                   C1TR45CONbits.TX4PRI    = 0b00; // Buffer TRB4 is lowest priority.  
001552  000104     NOP
001554  001004     NOP
001556  000004     NOP
001558  000104     NOP
127:                   
128:                   C1TR45CONbits.TXEN5     = 1;    // Buffer TRB5 is a transmit buffer.
00155A  000015     NOP
129:                   C1TR45CONbits.TX5PRI    = 0b00; // Buffer TRB5 is lowest priority. 
00155C  000004     NOP
00155E  000004     NOP
001560  040000     GOTO 0x0
001562  000100     NOP
130:                   
131:                   // -------------------------------------------------------------------------
132:                   //
133:                   // The S-Node needs to receive messages with CAN extended identifiers.
134:                   // Three messages are received over the CAN bus.  The following filters
135:                   // are configured to received CAN messages:
136:                   //      Filter 0 - Servo Command         (10)
137:                   //      Filter 1 - Servo Command         (10)
138:                   //      Filter 2 - Servo Command         (10)
139:                   //      Filter 3 - Configuration Write  (800)
140:                   //      Filter 4 - Configuration Read   (801)
141:                   //
142:                   // The Configuration Write and Read commands operate at a low-enough of a
143:                   // rate (and are not flight-critical) so a single receive buffer is used
144:                   // for processing of the messages.
145:                   //
146:                   // The Servo Command message is received at a rate which matches to
147:                   // software cycle rate.  Three message buffers are used to handle
148:                   // non-synchronization of nodes and to address jitter.  The hardware
149:                   // automatically stored a received message at the higher-indexed filter
150:                   // buffer pointer (BUFPNT) when the lower-indexed buffer is full.
151:                   //
152:                   // -------------------------------------------------------------------------
153:                   //
154:                   // Filter 0,1,2:
155:                   //  bits 28-19: Data Type           = 10
156:                   //  bits 18-17: Transfer Type       = 0b11  (Message Unicast)
157:                   //  bits 16-10: Source Node ID      = 0      (FMU)
158:                   //  bits  9- 7: Reserved            = x
159:                   //  bits  6- 0: Destination Node Id = n
160:                   //
161:                   //  bits 28-0 = 0_0000_0101_01 10_0000_00xx_xnnn_nnnn
162:                   //             |      SID    | |         EID        |
163:                   //
164:                   // Filter 3:
165:                   //  bits 28-19: Data Type           = 800
166:                   //  bits 18-17: Transfer Type       = 0b01  (Service Request)
167:                   //  bits 16-10: Source Node ID      = 0     (FMU)
168:                   //  bits  9- 7: Reserved            = x
169:                   //  bits  6- 0: Destination Node Id = n
170:                   //
171:                   //  bits 28-0 = 1_1001_0000_00 10_0000_00xx_xnnn_nnnn
172:                   //             |      SID    | |         EID        |
173:                   //
174:                   // Filter 4:
175:                   //  bits 28-19: Data Type           = 801
176:                   //  bits 18-17: Transfer Type       = 0b01  (Service Request)
177:                   //  bits 16-10: Source Node ID      = 0     (FMU)
178:                   //  bits  9- 7: Reserved            = x
179:                   //  bits  6- 0: Destination Node Id = n
180:                   //  
181:                   //  bits 28-0 = 1_1001_0000_10 10_0000_00xx_xnnn_nnnn
182:                   //             |      SID    | |         EID        |
183:                   //
184:                   C1CTRL1bits.WIN     = 1;    // Select the filters for visibility in SFRs.
001564  000000     NOP
185:                   
186:                   C1FEN1              = 0;    // Disabled all filters to start.
001566  800000     MOV WREG0, W0
001568  000000     NOP
187:                   C1FEN1bits.FLTEN0   = 1;    // Enable filter 0.
00156A  800010     MOV WREG1, W0
188:                   C1FEN1bits.FLTEN1   = 1;    // Enable filter 1.
00156C  004010     NOP
189:                   C1FEN1bits.FLTEN2   = 1;    // Enable filter 2.
00156E  000010     NOP
190:                   C1FEN1bits.FLTEN3   = 1;    // Enable filter 3.
001570  000014     NOP
191:                   C1FEN1bits.FLTEN4   = 1;    // Enable filter 4.
001572  000014     NOP
192:               
193:                   C1BUFPNT1bits.F0BP  = 8;    // Acceptance Filter 0 to use Message Buffer  8 to store message.
001574  200104     MOV #0x10, W4
001576  000004     NOP
001578  000804     NOP
00157A  000004     NOP
00157C  000004     NOP
00157E  010104     CALL W4
194:                   C1BUFPNT1bits.F1BP  = 9;    // Acceptance Filter 1 to use Message Buffer  9 to store message.
001580  000100     NOP
001582  000080     NOP
001584  000000     NOP
001586  000000     NOP
001588  004000     NOP
00158A  000100     NOP
195:                   C1BUFPNT1bits.F2BP  = 10;   // Acceptance Filter 2 to use Message Buffer 10 to store message.
00158C  000100     NOP
00158E  000800     NOP
001590  000004     NOP
001592  000804     NOP
001594  000004     NOP
001596  080104     DO #260, CANRxGet
196:                   C1BUFPNT1bits.F3BP  = 11;   // Acceptance Filter 3 to use Message Buffer 11 to store message.   
001598  800104     MOV SPLIM, W4
00159A  000004     NOP
00159C  008004     NOP
00159E  000004     NOP
0015A0  000000     NOP
0015A2  000100     NOP
197:                   C1BUFPNT2bits.F4BP  = 12;   // Acceptance Filter 4 to use Message Buffer 12 to store message.
0015A4  000100     NOP
0015A6  000002     NOP
0015A8  020000     CALL 0x0
0015AA  000000     NOP
0015AC  000000     NOP
0015AE  001100     NOP
198:                    
199:                   C1RXF0SIDbits.SID   = 0x015;    // Set filter 0 match values.
0015B0  000004     NOP
0015B2  00006C     NOP
0015B4  000084     NOP
0015B6  000005     NOP
0015B8  000804     NOP
200:                   C1RXF0SIDbits.EXIDE = 1;        // Match messages only with extended ID.
0015BA  000040     NOP
201:                   C1RXF0SIDbits.EID   = 0x2;      // Set filter 0 match values.
0015BC  000004     NOP
0015BE  000004     NOP
0015C0  000000     NOP
0015C2  100000     SUBR W0, W0, W0
202:                   C1RXF0EID           = node_id;  // Set filter 0 match values.
0015C4  000010     NOP
0015C6  000001     NOP
0015C8  000010     NOP
203:               
204:                   C1RXF1SIDbits.SID   = 0x015;    // Set filter 1 match values.
0015CA  000021     NOP
0015CC  000073     NOP
0015CE  000400     NOP
0015D0  000004     NOP
0015D2  000004     NOP
205:                   C1RXF1SIDbits.EXIDE = 1;        // Match messages only with extended ID.
0015D4  000044     NOP
206:                   C1RXF1SIDbits.EID   = 0x2;      // Set filter 1 match values.
0015D6  000024     NOP
0015D8  040004     GOTO 0x40004
0015DA  000004     NOP
0015DC  010024     CALL W4
207:                   C1RXF1EID           = node_id;  // Set filter 1 match values.
0015DE  000116     NOP
0015E0  000000     NOP
0015E2  000030     NOP
208:                   
209:                   C1RXF2SIDbits.SID   = 0x015;    // Set filter 2 match values.
0015E4  000040     NOP
0015E6  000179     NOP
0015E8  000000     NOP
0015EA  000000     NOP
0015EC  000040     NOP
210:                   C1RXF2SIDbits.EXIDE = 1;        // Match messages only with extended ID.
0015EE  010048     CALL W8
211:                   C1RXF2SIDbits.EID   = 0x2;      // Set filter 2 match values.
0015F0  000044     NOP
0015F2  010004     CALL W4
0015F4  008004     NOP
0015F6  000044     NOP
212:                   C1RXF2EID           = node_id;  // Set filter 2 match values.
0015F8  00001E     NOP
0015FA  100004     SUBR W0, W4, W0
0015FC  000054     NOP
213:                   
214:                   C1RXF3SIDbits.SID   = 0x640;    // Set filter 3 match values.
0015FE  000074     NOP
001600  000080     NOP
001602  000400     NOP
001604  000001     NOP
001606  800000     MOV WREG0, W0
215:                   C1RXF3SIDbits.EXIDE = 1;        // Match messages only with extended ID.
001608  000000     NOP
216:                   C1RXF3SIDbits.EID   = 0x2;      // Set filter 3 match values.
00160A  000002     NOP
00160C  020000     CALL 0x0
00160E  000000     NOP
001610  000004     NOP
217:                   C1RXF3EID           = node_id;  // Set filter 3 match values.
001612  000004     NOP
001614  004004     NOP
001616  000004     NOP
218:                   
219:                   C1RXF4SIDbits.SID   = 0x641;    // Set filter 4 match values.
001618  000084     NOP
00161A  000186     NOP
00161C  000044     NOP
00161E  000005     NOP
001620  000080     NOP
220:                   C1RXF4SIDbits.EXIDE = 1;        // Match messages only with extended ID.
001622  000400     NOP
221:                   C1RXF4SIDbits.EID   = 0x2;      // Set filter 4 match values.
001624  000080     NOP
001626  000000     NOP
001628  000800     NOP
00162A  000080     NOP
222:                   C1RXF4EID           = node_id;  // Set filter 4 match values.
00162C  00008A     NOP
00162E  000001     NOP
001630  000084     NOP
223:                   
224:                   C1FMSKSEL1bits.F0MSK = 0b00;    // Set filter 0 for mask 0 match.
001632  010084     CALL W4
001634  000004     NOP
001636  000004     NOP
001638  000084     NOP
225:                   C1FMSKSEL1bits.F1MSK = 0b00;    // Set filter 1 for mask 0 match.
00163A  100084     SUBR W0, W4, W1
00163C  000004     NOP
00163E  000004     NOP
001640  000080     NOP
226:                   C1FMSKSEL1bits.F2MSK = 0b00;    // Set filter 2 for mask 0 match.
001642  000080     NOP
001644  000000     NOP
001646  000000     NOP
001648  400080     ADD W0, W0, W1
227:                   C1FMSKSEL1bits.F3MSK = 0b00;    // Set filter 3 for mask 0 match.
00164A  000080     NOP
00164C  000000     NOP
00164E  000000     NOP
001650  000084     NOP
228:                   C1FMSKSEL1bits.F4MSK = 0b00;    // Set filter 4 for mask 0 match.
001652  00008C     NOP
001654  000004     NOP
001656  400004     ADD W0, W4, W0
001658  800084     MOV WREG8, W4
229:                   
230:                   C1RXM0SIDbits.SID   = 0x7FF;  // Set mask 0 - match bits 28-18.
00165A  000184     NOP
00165C  000004     NOP
00165E  000015     NOP
001660  000180     NOP
231:                   C1RXM0SIDbits.MIDE  = 1;      // Only match extended IDs.
001662  004010     NOP
232:                   C1RXM0SIDbits.EID   = 0x3;    // Set mask 0 - match bits 17-16.
001664  000180     NOP
001666  100000     SUBR W0, W0, W0
001668  010000     CALL W0
00166A  000180     NOP
233:                   C1RXM0EID           = 0xFC7F; // Set mask 0 - match bits 15-10 & 6-0, ignore bits 9-7.
00166C  008190     NOP
00166E  000190     NOP
234:                   
235:                   // Configure DMA0 for CAN1 transmit operation.
236:                   DMA0CONbits.SIZE    = 0;                                                    // Perform word transfers.
001670  100100     SUBR W0, W0, W2
237:                   DMA0CONbits.DIR     = 1;                                                    // Transfer from RAM to the peripheral address.
001672  000100     NOP
238:                   DMA0CONbits.HALF    = 0;                                                    // Do not generate interrupt when half of data moved.
001674  000101     NOP
239:                   DMA0CONbits.NULLW   = 0;                                                    // Normal operation.
001676  000101     NOP
240:                   DMA0CONbits.AMODE   = 0b10;                                                 // Peripheral indirect addressing mode.
001678  000004     NOP
00167A  000004     NOP
00167C  000004     NOP
00167E  000004     NOP
241:                   DMA0CONbits.MODE    = 0b00;                                                 // Continuous Ping-Pong modes disabled.
001680  000000     NOP
001682  000080     NOP
001684  000000     NOP
001686  000000     NOP
242:                   DMA0REQbits.IRQSEL  = 70;                                                   // Associate the DMA channel to IRQ 70 (i.e. CAN1 TX Data Request)
001688  100020     SUBR W0, [W0--], W0
00168A  000080     NOP
00168C  00002A     NOP
00168E  000101     NOP
243:                   DMA0CNTbits.CNT     = 7;                                                    // Perform 8 transfers.
001690  000024     NOP
001692  000004     NOP
001694  000004     NOP
001696  000024     NOP
001698  000024     NOP
244:                   DMA0PAD             = (volatile unsigned int) &C1TXD;                       // Peripheral address of CAN1 transmit data register.
00169A  000024     NOP
00169C  000025     NOP
245:                   DMA0STAL            = (unsigned int) &can_msg_buf;                          // Set the DMA0 start address register.    
00169E  000004     NOP
0016A0  000020     NOP
246:                   DMA0STAH            = 0x0000;                                               // N/A near memory accessed
0016A2  000040     NOP
0016A4  000022     NOP
247:                   DMA0CONbits.CHEN    = 1;                                                    // Enable the DMA0 channel.
0016A6  000101     NOP
248:                   
249:                   // Configure DMA1 for CAN1 receive operation.
250:                   DMA1CONbits.SIZE    = 0;                                                    // Perform word transfers.
0016A8  000100     NOP
251:                   DMA1CONbits.DIR     = 0;                                                    // Transfer from peripheral address to RAM.
0016AA  000100     NOP
252:                   DMA0CONbits.HALF    = 0;                                                    // Do not generate interrupt when half of data moved.
0016AC  200101     MOV #0x10, W1
253:                   DMA0CONbits.NULLW   = 0;                                                    // Normal operation.
0016AE  000101     NOP
254:                   DMA1CONbits.AMODE   = 0b10;                                                 // Peripheral indirect addressing mode.
0016B0  000284     NOP
0016B2  000004     NOP
0016B4  000004     NOP
0016B6  020084     CALL 0x40084
255:                   DMA1CONbits.MODE    = 0b00;                                                 // Continuous Ping-Pong modes disabled.
0016B8  800084     MOV WREG8, W4
0016BA  000004     NOP
0016BC  000004     NOP
0016BE  000884     NOP
256:                   DMA0REQbits.IRQSEL  = 34;                                                   // Associate the DMA channel to IRQ 34 (i.e. CAN1 Receive Data Ready)
0016C0  000020     NOP
0016C2  000080     NOP
0016C4  000020     NOP
0016C6  000101     NOP
257:                   DMA0CNTbits.CNT     = 7;                                                    // Perform 8 transfers.
0016C8  004030     NOP
0016CA  000000     NOP
0016CC  000000     NOP
0016CE  000010     NOP
0016D0  000035     NOP
258:                   DMA1PAD             = (volatile unsigned int) &C1RXD;                       // Peripheral address of CAN1 transmit data register.
0016D2  000004     NOP
0016D4  0200A4     CALL 0x400A4
259:                   DMA1STAL            = (unsigned int) &can_msg_buf;                          // Set the DMA0 start address register.    
0016D6  000004     NOP
0016D8  0000A4     NOP
260:                   DMA1STAH            = 0x0000;                                               // N/A near memory accessed
0016DA  040000     GOTO 0x340000
0016DC  0000B4     NOP
261:                   DMA1CONbits.CHEN    = 1;                                                    // Enable the DMA1 channel.            
0016DE  000191     NOP
262:                   
263:                   C1CTRL1bits.WIN = 0; // select the buffer window for visibility in SFRs.
0016E0  000000     NOP
264:                   
265:                   // Request Normal Operating Mode
266:                   C1CTRL1bits.REQOP = 0;
0016E2  400000     ADD W0, W0, W0
0016E4  000000     NOP
0016E6  000000     NOP
0016E8  000000     NOP
0016EA  000000     NOP
267:                   
268:                   // Wait for the ECAN module to enter into Normal Operating Mode
269:                   while(C1CTRL1bits.OPMODE != 0);
0016EC  000000     NOP
0016EE  000001     NOP
0016F0  000004     NOP
0016F2  020004     CALL 0x4
0016F4  000180     NOP
0016F6  0001B9     NOP
270:               }
0016F8  000000     NOP
0016FA  000001     NOP
271:               
272:               void CANTxSet ( CAN_TX_MSG_TYPE_E tx_msg_type, const uint16_t payload[ 4 ] )
273:               {
0016FC  000006     NOP
0016FE  020110     CALL 0x110
001700  000100     NOP
274:                   // Structure definition of HW elements corresponding the a message type.
275:                   typedef struct
276:                   {
277:                       uint8_t buffer_index;
278:                       volatile uint16_t* trcon_p;
279:                       uint16_t txreq_mask;
280:                      
281:                   } TX_HW_MAP_S;
282:                   
283:                   // Mapping of message types to hardware elements for transmitting the message.
284:                   static const TX_HW_MAP_S tx_hw_map[ CAN_TX_MSG_NUM_OF ] = 
285:                   {
286:                       { 0, &C1TR01CON, 0x0008 },   // CAN_TX_MSG_SERVO_STATUS
287:                       { 1, &C1TR01CON, 0x0800 },   // CAN_TX_MSG_VSENSE_DATA
288:                       { 2, &C1TR23CON, 0x0008 },   // CAN_TX_MSG_NODE_STATUS
289:                       { 3, &C1TR23CON, 0x0800 },   // CAN_TX_MSG_NODE_VER
290:                       { 4, &C1TR45CON, 0x0008 },   // CAN_TX_MSG_CFG_WRITE_RESP
291:                       { 5, &C1TR45CON, 0x0800 },   // CAN_TX_MSG_CFG_READ_RESP
292:                   };
293:                   
294:                   uint8_t buf_idx;
295:                   uint8_t payload_idx;
296:                   
297:                   // Transmission request is not already set - i.e. a tranmission is not
298:                   // already in progress for the transmit buffer ?
299:                   if( ( *tx_hw_map[ tx_msg_type ].trcon_p & tx_hw_map[ tx_msg_type ].txreq_mask ) != 1 )
001702  000008     NOP
001704  0100C0     CALL W0
001706  000080     NOP
001708  000180     NOP
00170A  400000     ADD W0, W0, W0
00170C  000400     NOP
00170E  000080     NOP
001710  000804     NOP
001712  0000C4     NOP
001714  010144     CALL W4
001716  000184     NOP
001718  000004     NOP
00171A  000004     NOP
00171C  000004     NOP
00171E  0801C1     DO #449, 0x1732
001720  000008     NOP
300:                   {   
301:                       // Copy buffer index to local variable for processing efficiency
302:                       // and reduced line length.
303:                       buf_idx = tx_hw_map[ tx_msg_type ].buffer_index;
001722  000088     NOP
001724  0100C0     CALL W0
001726  000080     NOP
001728  000180     NOP
00172A  020000     CALL 0x0
00172C  000100     NOP
00172E  000112     NOP
304:                       
305:                       // Copy the payload to the transmit buffer.
306:                       for( payload_idx = 0;
001730  000000     NOP
001732  000104     NOP
001734  000000     NOP
00175A  000116     NOP
00175C  4001C3     ADD W0, [--W3], W3
00175E  0001C3     NOP
307:                            payload_idx < 4;
308:                            payload_idx++ )
001758  000116     NOP
309:                       {
310:                           // Note: First 3 words of hardware buffer are used for CAN ID,
311:                           // DLC, and control bits.
312:                           can_msg_buf[ buf_idx ][ payload_idx + 3 ] = payload[ payload_idx ];
001736  02000C     CALL 0x44000C
001738  0001C4     NOP
00173A  00008E     NOP
00173C  000005     NOP
00173E  000543     NOP
001740  000110     NOP
001742  000000     NOP
001744  020000     CALL 0x0
001746  000080     NOP
001748  200000     MOV #0x0, W0
00174A  000090     NOP
00174C  008043     NOP
00174E  000002     NOP
001750  080104     DO #260, 0x175C
001752  000004     NOP
001754  00000C     NOP
001756  000005     NOP
313:                       }
314:               
315:                       // Build the CAN message header.
316:                       CANTxBuildHeader( tx_msg_type, &can_msg_buf[ buf_idx ][ 0 ] );
001760  000000     NOP
001762  020018     CALL 0x18
001764  040000     GOTO 0x400000
001766  000040     NOP
001768  008000     NOP
00176A  000080     NOP
00176C  00001A     NOP
00176E  000493     NOP
317:                       
318:                       // Request (i.e. set request bit to '1') the transmission.
319:                       *tx_hw_map[ tx_msg_type ].trcon_p |= tx_hw_map[ tx_msg_type ].txreq_mask;
001770  80001C     MOV WREG1, W12
001772  0000C4     NOP
001774  000884     NOP
001776  000184     NOP
001778  000004     NOP
00177A  000014     NOP
00177C  00009E     NOP
00177E  0081C6     NOP
001780  000080     NOP
001782  000100     NOP
001784  0001A1     NOP
001786  010081     CALL W1
001788  000080     NOP
00178A  020100     CALL 0x20100
00178C  000082     NOP
00178E  0001E2     NOP
001790  0000A0     NOP
001792  0001E4     NOP
001794  0001A5     NOP
001796  000081     NOP
001798  000084     NOP
00179A  0000C6     NOP
00179C  000005     NOP
320:                   }
321:               }
00179E  100000     SUBR W0, W0, W0
0017A0  000002     NOP
322:               
323:               bool CANRxGet ( CAN_RX_MSG_TYPE_E rx_msg_type, uint16_t payload[ 4 ] )
324:               {
0017A2  000008     NOP
0017A4  000120     NOP
0017A6  000921     NOP
325:                   // Structure definition of HW elements corresponding the a message type.
326:                   typedef struct
327:                   {
328:                       uint8_t buffer_index;
329:                       volatile uint16_t* rxful_p;
330:                       uint16_t rxful_mask;
331:                      
332:                   } RX_HW_MAP_S;
333:                   
334:                   static const RX_HW_MAP_S hw_map_servo_cmd[] = 
335:                   {
336:                       {  8, &C1RXFUL1, 0x0100 },
337:                       {  9, &C1RXFUL1, 0x0200 },
338:                       { 10, &C1RXFUL1, 0x0400 },
339:                       {  0, NULL,      0x0000 },   // NULL terminated
340:                   };
341:                   
342:                   static const RX_HW_MAP_S hw_map_cfg_write[] = 
343:                   {
344:                       { 11, &C1RXFUL1, 0x0800 },
345:                       {  0, NULL,      0x0000 },   // NULL terminated
346:                   };
347:                   
348:                   static const RX_HW_MAP_S hw_map_cfg_read[] = 
349:                   {
350:                       { 12, &C1RXFUL1, 0x1000 },
351:                       {  0, NULL,      0x0000 },   // NULL terminated
352:                   };
353:                   
354:                   static const RX_HW_MAP_S* const rx_hw_map[ CAN_RX_MSG_NUM_OF ] =
355:                   {
356:                       &hw_map_servo_cmd[ 0 ],     // CAN_RX_MSG_SERVO_CMD
357:                       &hw_map_cfg_write[ 0 ],     // CAN_RX_MSG_CFG_WRITE_REQ
358:                       &hw_map_cfg_read[ 0 ],      // CAN_RX_MSG_CFG_READ_REQ
359:                   };
360:                   
361:                   
362:                   uint8_t payload_idx;
363:                   uint8_t map_idx;
364:                   
365:                   bool    data_rx_flag = false;
0017A8  000000     NOP
0017AA  200120     MOV #0x12, W0
366:                   uint8_t buf_idx;
367:                   
368:                   // Determine buffer index which contains the freshest data.
369:                   for( map_idx = 0;
0017AC  000000     NOP
0017AE  000100     NOP
0017B0  000060     NOP
00188A  520FE0     SUB W4, #0x0, [W15]
00188C  3AFF92     BRA NZ, 0x17B2
370:                        rx_hw_map[ rx_msg_type ][ map_idx ].rxful_p != NULL;
001876  90022E     MOV [W14+4], W4
001878  420284     ADD W4, W4, W5
00187A  294244     MOV #0x9424, W4
00187C  428204     ADD W5, W4, W4
00187E  780294     MOV [W4], W5
001880  90421E     MOV.B [W14+1], W4
001882  FB8204     ZE W4, W4
001884  B922E6     MUL.SU W4, #6, W4
001886  428204     ADD W5, W4, W4
001888  900214     MOV [W4+2], W4
371:                        map_idx++ )
001870  90421E     MOV.B [W14+1], W4
001872  E84204     INC.B W4, W4
001874  984714     MOV.B W4, [W14+1]
372:                   {
373:                       // Buffer is full ?
374:                       if( ( *rx_hw_map[ rx_msg_type ][ map_idx ].rxful_p & 
0017B2  00006C     NOP
0017B4  000084     NOP
0017B6  000044     NOP
0017B8  200004     MOV #0x0, W4
0017BA  000084     NOP
0017BC  00000E     NOP
0017BE  080004     DO #4, 0x1982
0017C0  0000E0     NOP
0017C2  010000     CALL W0
0017C4  000010     NOP
0017C6  000090     NOP
0017DC  010004     CALL W4
0017DE  0001E1     NOP
0017E0  000048     NOP
375:                                   rx_hw_map[ rx_msg_type ][ map_idx ].rxful_mask ) == 1 )
0017C8  400022     ADD W0, [W2--], W0
0017CA  000100     NOP
0017CC  000040     NOP
0017CE  008000     NOP
0017D0  000114     NOP
0017D2  000014     NOP
0017D4  000004     NOP
0017D6  2000E4     MOV #0xE, W4
0017D8  000004     NOP
0017DA  200024     MOV #0x2, W4
376:                       {
377:                           // Identify data as received.
378:                           data_rx_flag  = true;
0017E2  000010     NOP
0017E4  010120     CALL W0
379:                           
380:                           // Copy buffer index to local variable for processing efficiency
381:                           // and reduced line length.
382:                           buf_idx = rx_hw_map[ rx_msg_type ][ map_idx ].buffer_index;
0017E6  000028     NOP
0017E8  000080     NOP
0017EA  000041     NOP
0017EC  000000     NOP
0017EE  000092     NOP
0017F0  02001C     CALL 0x4001C
0017F2  000004     NOP
0017F4  8000E4     MOV WREG14, W4
0017F6  000004     NOP
0017F8  000094     NOP
0017FA  040134     GOTO 0x134
383:               
384:                           // Copy payload into supplied buffer.
385:                           for ( payload_idx = 0;
0017FC  000000     NOP
0017FE  000104     NOP
001800  370012     BRA 0x1826
001826  78421E     MOV.B [W14], W4
001828  524FE3     SUB.B W4, #0x3, [W15]
00182A  36FFEB     BRA LEU, 0x1802
386:                                 payload_idx < 4;
387:                                 payload_idx++ )
001824  E84F1E     INC.B [W14], [W14]
388:                           {
389:                               // Note: First 3 words of hardware buffer are used for CAN ID,
390:                               // DLC, and control bits.
391:                               payload[ payload_idx ] = can_msg_buf[ buf_idx ][ payload_idx + 3 ];
001802  78439E     MOV.B [W14], W7
001804  FB8207     ZE W7, W4
001806  420204     ADD W4, W4, W4
001808  9002BE     MOV [W14+6], W5
00180A  428284     ADD W5, W4, W5
00180C  90423E     MOV.B [W14+3], W4
00180E  FB8304     ZE W4, W6
001810  78439E     MOV.B [W14], W7
001812  FB8207     ZE W7, W4
001814  420263     ADD W4, #0x3, W4
001816  DD3343     SL W6, #3, W6
001818  430204     ADD W6, W4, W4
00181A  420304     ADD W4, W4, W6
00181C  215004     MOV #0x1500, W4
00181E  430204     ADD W6, W4, W4
001820  780214     MOV [W4], W4
001822  780A84     MOV W4, [W5]
392:                           }
393:                           
394:                           // Clear the receiver buffer flag so the hardware will receive a
395:                           // new message into the buffer.
396:                           *rx_hw_map[ rx_msg_type ][ map_idx ].rxful_p |= ~rx_hw_map[ rx_msg_type ][ map_idx ].rxful_mask;
00182C  90022E     MOV [W14+4], W4
00182E  420284     ADD W4, W4, W5
001830  294244     MOV #0x9424, W4
001832  428204     ADD W5, W4, W4
001834  780294     MOV [W4], W5
001836  90421E     MOV.B [W14+1], W4
001838  FB8204     ZE W4, W4
00183A  B922E6     MUL.SU W4, #6, W4
00183C  428204     ADD W5, W4, W4
00183E  900294     MOV [W4+2], W5
001840  90022E     MOV [W14+4], W4
001842  420304     ADD W4, W4, W6
001844  294244     MOV #0x9424, W4
001846  430204     ADD W6, W4, W4
001848  780314     MOV [W4], W6
00184A  90421E     MOV.B [W14+1], W4
00184C  FB8204     ZE W4, W4
00184E  B922E6     MUL.SU W4, #6, W4
001850  430204     ADD W6, W4, W4
001852  900214     MOV [W4+2], W4
001854  780314     MOV [W4], W6
001856  90022E     MOV [W14+4], W4
001858  420384     ADD W4, W4, W7
00185A  294244     MOV #0x9424, W4
00185C  438204     ADD W7, W4, W4
00185E  780394     MOV [W4], W7
001860  90421E     MOV.B [W14+1], W4
001862  FB8204     ZE W4, W4
001864  B922E6     MUL.SU W4, #6, W4
001866  438204     ADD W7, W4, W4
001868  900224     MOV [W4+4], W4
00186A  EA8204     COM W4, W4
00186C  720206     IOR W4, W6, W4
00186E  780A84     MOV W4, [W5]
397:                       }
398:                   }
399:                
400:                   return data_rx_flag;
00188E  90422E     MOV.B [W14+2], W4
401:               }
001890  784004     MOV.B W4, W0
001892  FA8000     ULNK
001894  060000     RETURN
402:               
403:               // *****************************************************************************
404:               // ************************** Static Functions *********************************
405:               // *****************************************************************************
406:               
407:               ////////////////////////////////////////////////////////////////////////////////
408:               /// @brief 
409:               /// @param 
410:               /// @return
411:               ////////////////////////////////////////////////////////////////////////////////
412:               static void CANTxBuildHeader ( CAN_TX_MSG_TYPE_E tx_msg_type, uint16_t msg_buf[ 8 ] )
413:               {
001896  FA0016     LNK #0x16
001898  980F10     MOV W0, [W14+18]
00189A  980F21     MOV W1, [W14+20]
414:                   // Union defining the contents of the CAN ID field.
415:                   typedef union
416:                   {
417:                       struct
418:                       {
419:                           uint32_t dest_id    :  7;   // bits 6 - 0
420:                           uint32_t            :  3;   // bits 9 - 7 (reserved)
421:                           uint32_t src_id     :  7;   // bits 16-10
422:                           uint32_t tsf_type   :  2;   // bits 18-17
423:                           uint32_t data_type  : 10;   // bits 28-19
424:                       };
425:                       
426:                       struct
427:                       {
428:                           uint32_t id3        : 11;   // bits 10- 0
429:                           uint32_t id2        : 12;   // bits 22-11
430:                           uint32_t id1        :  6;   // bits 28-23
431:                       };
432:                       
433:                   } CAN_ID_U;
434:                   
435:                   // Structure defining the contents of the CAN header and footer.
436:                   typedef struct
437:                   {
438:                       uint8_t  data_len;
439:                       CAN_ID_U can_id;
440:                       
441:                   } CAN_DATA_S;
442:                   
443:                   // Structure defining the contents of the CAN message header within the
444:                   // hardware buffer.
445:                   typedef struct
446:                   {
447:                       struct
448:                       {
449:                           // Word 1.
450:                           uint16_t ide    :  1;
451:                           uint16_t srr    :  1;
452:                           uint16_t id1    : 11;
453:                           uint16_t        :  3;
454:               
455:                           // Word 2.
456:                           uint16_t id2    : 12;
457:                           uint16_t        :  4;
458:               
459:                           // Word 3.
460:                           uint16_t dlc    :  4;
461:                           uint16_t rb0    :  1;
462:                           uint16_t        :  3;
463:                           uint16_t rb1    :  1;
464:                           uint16_t rtr    :  1;
465:                           uint16_t id3    :  6; 
466:                       };
467:                       
468:                       uint16_t data_u16[ 3 ];
469:                       
470:                   } CAN_HW_HEADER_U;
471:                   
472:                   // Defined messages' header content and message length.
473:                   static const CAN_DATA_S tx_can_data[ CAN_TX_MSG_NUM_OF ] =
474:                   {
475:                       // CAN_TX_MSG_SERVO_STATUS
476:                       {
477:                           8,              // data_len
478:                           
479:                           {
480:                               {
481:                                   0,          // dest_id      - N/A, broadcast message.
482:                                   0,          // src_id       - N/A, set real-time.        
483:                                   0b10,       // tsf_type     - Message broadcast.
484:                                   20,         // data_type    - 20 identifies Servo Status Message.
485:                               },
486:                           },
487:                       },
488:                       
489:                       // CAN_TX_MSG_VSENSE_DATA
490:                       {
491:                           8,              // data_len
492:                           
493:                           {
494:                               {
495:                                   0,          // dest_id      - N/A, broadcast message.
496:                                   0,          // src_id       - N/A, set real-time.        
497:                                   0b10,       // tsf_type     - Message broadcast.
498:                                   21,         // data_type    - 20 identifies VSENSE Status Message.
499:                               },
500:                           },
501:                       },
502:                       
503:                       // CAN_TX_MSG_NODE_STATUS
504:                       {
505:                           4,              // data_len
506:                           
507:                           {
508:                               {
509:                                   0,          // dest_id      - N/A, broadcast message.
510:                                   0,          // src_id       - N/A, set real-time.        
511:                                   0b10,       // tsf_type     - Message broadcast.
512:                                   770,        // data_type    - 770 identifies Node Status Message.
513:                               },
514:                           },
515:                       },
516:                       
517:                       // CAN_TX_MSG_NODE_VER
518:                       {
519:                           8,              // data_len
520:                           
521:                           {
522:                               {
523:                                   0,          // dest_id      - N/A, broadcast message.
524:                                   0,          // src_id       - N/A, set real-time.        
525:                                   0b10,       // tsf_type     - Message broadcast.
526:                                   771,        // data_type    - 771 identifies Node Type and Version Message.
527:                               },
528:                           },
529:                       },
530:                       
531:                       // CAN_TX_MSG_CFG_WRITE_RESP
532:                       {
533:                           6,              // data_len
534:                           
535:                           {
536:                               {
537:                                   0,          // dest_id      - Send to FMU (ID = 0).
538:                                   0,          // src_id       - N/A, set real-time.        
539:                                   0b00,       // tsf_type     - Service Response.
540:                                   800,        // data_type    - 800 identifies Configuration Write Response Message.
541:                               },
542:                           },
543:                       },
544:                       
545:                       // CAN_TX_MSG_CFG_READ_RESP
546:                       {
547:                           0,              // data_len     - Variable, special case treated with execution.
548:                           
549:                           {
550:                               {
551:                                   0,          // dest_id      - Send to FMU (ID = 0).
552:                                   0,          // src_id       - N/A, set real-time.        
553:                                   0b00,       // tsf_type     - Service Response.
554:                                   801,        // data_type    - 801 identifies Configuration Read Response Message.
555:                               },
556:                           },
557:                       },
558:                   };
559:                   
560:                   
561:                   //
562:                   // START OF OPERATIONAL CODE AND LOCAL VARIABLE DEFINITIONS ----------------
563:                   //
564:                   
565:                   CAN_ID_U can_id;
566:                   
567:                   // Define the header content.  Set fields which are identical independent
568:                   // of the message type.
569:                   CAN_HW_HEADER_U tx_hw_header =
00189C  470266     ADD W14, #0x6, W4
00189E  090005     REPEAT #0x5
0018A0  EB1A00     CLR [W4++]
0018A2  90023E     MOV [W14+6], W4
0018A4  A00004     BSET W4, #0
0018A6  980734     MOV W4, [W14+6]
0018A8  90023E     MOV [W14+6], W4
0018AA  A01004     BSET W4, #1
0018AC  980734     MOV W4, [W14+6]
570:                   {
571:                       {
572:                           1,            // ide - always recessive.
573:                           1,            // srr - always recessive.
574:                           0,            // id1 - updated in fxn.
575:                           0,            // id2 - updated in fxn.
576:                           0,            // dlc - updated in fxn.
577:                           0,            // rb0 - always dominant.
578:                           0,            // rb1 - always dominant.
579:                           0,            // rtr - always dominant for data frames.
580:                           0,            // id3 - updated in fxn.
581:                       },
582:                   };
583:                   
584:                   uint8_t node_id;
585:                   
586:                   node_id = CfgNodeIdGet();
0018AE  07FA71     RCALL CfgNodeIdGet
0018B0  784200     MOV.B W0, W4
0018B2  784F04     MOV.B W4, [W14]
587:                   
588:                   // Copy the CAN ID from NVM and update the Node ID.
589:                   can_id        = tx_can_data[ tx_msg_type ].can_id;
0018B4  900A1E     MOV [W14+18], W4
0018B6  B922E6     MUL.SU W4, #6, W4
0018B8  E88284     INC2 W4, W5
0018BA  294004     MOV #0x9400, W4
0018BC  428204     ADD W5, W4, W4
0018BE  BE0314     MOV.D [W4], W6
0018C0  980716     MOV W6, [W14+2]
0018C2  980727     MOV W7, [W14+4]
590:                   can_id.src_id = node_id;
0018C4  78421E     MOV.B [W14], W4
0018C6  A17404     BCLR.B W4, #7
0018C8  FB8304     ZE W4, W6
0018CA  2003F5     MOV #0x3F, W5
0018CC  630285     AND W6, W5, W5
0018CE  DD2ACA     SL W5, #10, W5
0018D0  90039E     MOV [W14+2], W7
0018D2  203FF6     MOV #0x3FF, W6
0018D4  638306     AND W7, W6, W6
0018D6  728286     IOR W5, W6, W5
0018D8  980715     MOV W5, [W14+2]
0018DA  FB8204     ZE W4, W4
0018DC  DE2246     LSR W4, #6, W4
0018DE  FB8204     ZE W4, W4
0018E0  620261     AND W4, #0x1, W4
0018E2  620261     AND W4, #0x1, W4
0018E4  90032E     MOV [W14+4], W6
0018E6  2FFFE5     MOV #0xFFFE, W5
0018E8  630285     AND W6, W5, W5
0018EA  720205     IOR W4, W5, W4
0018EC  980724     MOV W4, [W14+4]
591:                   
592:                   // Populate the header within hardware with the CAN ID.
593:                   tx_hw_header.id1 = can_id.id1;
0018EE  90022E     MOV [W14+4], W4
0018F0  DE2247     LSR W4, #7, W4
0018F2  B243F4     AND.B #0x3F, W4
0018F4  FB8204     ZE W4, W4
0018F6  207FF5     MOV #0x7FF, W5
0018F8  620205     AND W4, W5, W4
0018FA  207FF5     MOV #0x7FF, W5
0018FC  620205     AND W4, W5, W4
0018FE  DD2242     SL W4, #2, W4
001900  90033E     MOV [W14+6], W6
001902  2E0035     MOV #0xE003, W5
001904  630285     AND W6, W5, W5
001906  720205     IOR W4, W5, W4
001908  980734     MOV W4, [W14+6]
594:                   tx_hw_header.id2 = can_id.id2;
00190A  90021E     MOV [W14+2], W4
00190C  DE224B     LSR W4, #11, W4
00190E  90032E     MOV [W14+4], W6
001910  2007F5     MOV #0x7F, W5
001912  630285     AND W6, W5, W5
001914  DD2AC5     SL W5, #5, W5
001916  720205     IOR W4, W5, W4
001918  780284     MOV W4, W5
00191A  20FFF4     MOV #0xFFF, W4
00191C  628204     AND W5, W4, W4
00191E  90034E     MOV [W14+8], W6
001920  2F0005     MOV #0xF000, W5
001922  630285     AND W6, W5, W5
001924  720205     IOR W4, W5, W4
001926  980744     MOV W4, [W14+8]
595:                   tx_hw_header.id3 = can_id.id3;
001928  90029E     MOV [W14+2], W5
00192A  207FF4     MOV #0x7FF, W4
00192C  628204     AND W5, W4, W4
00192E  784204     MOV.B W4, W4
001930  B243F4     AND.B #0x3F, W4
001932  FB8204     ZE W4, W4
001934  DD224A     SL W4, #10, W4
001936  90035E     MOV [W14+10], W6
001938  203FF5     MOV #0x3FF, W5
00193A  630285     AND W6, W5, W5
00193C  720205     IOR W4, W5, W4
00193E  980754     MOV W4, [W14+10]
596:                   
597:                   // Handle the special case of Configuration Read Response which has a
598:                   // variable length.
599:                   if( tx_msg_type == CAN_TX_MSG_CFG_READ_RESP )
001940  900A1E     MOV [W14+18], W4
001942  520FE5     SUB W4, #0x5, [W15]
001944  3A0013     BRA NZ, 0x196C
600:                   {
601:                       // For the Configuration Read Response message, the first word within
602:                       // the payload (i.e. buffer word 3) identifies the type of data
603:                       // returned.  Possible data includes:
604:                       //
605:                       //  Payload word 3      Description             Length (in bytes)
606:                       //  0                   Node ID                 1
607:                       //  1-6                 PWM coefficients        4 (each)
608:                       //  7-12                VSENSE1 Coefficients    4 (each)
609:                       //  13-18               VSENSE2 Coefficients    4 (each)
610:                       //
611:                       // The data length (dlc) for each Read Response Message is 2 bytes for
612:                       // the type identifier (i.e. buffer word 3) plus the value's length.
613:                       //
614:                       if( msg_buf[ 3 ] == 0 )
001946  900A2E     MOV [W14+20], W4
001948  420266     ADD W4, #0x6, W4
00194A  780214     MOV [W4], W4
00194C  520FE0     SUB W4, #0x0, [W15]
00194E  3A0007     BRA NZ, 0x195E
615:                       {
616:                           tx_hw_header.dlc = 2 + 1;
001950  90025E     MOV [W14+10], W4
001952  A00004     BSET W4, #0
001954  A01004     BSET W4, #1
001956  A12004     BCLR W4, #2
001958  A13004     BCLR W4, #3
00195A  980754     MOV W4, [W14+10]
00195C  370015     BRA 0x1988
617:                       }
618:                       else
619:                       {
620:                           tx_hw_header.dlc = 2 + 4;
00195E  90025E     MOV [W14+10], W4
001960  A10004     BCLR W4, #0
001962  A01004     BSET W4, #1
001964  A02004     BSET W4, #2
001966  A13004     BCLR W4, #3
001968  980754     MOV W4, [W14+10]
00196A  37000E     BRA 0x1988
621:                       }
622:                   }
623:                   else
624:                   {
625:                       // The message is not a Configuration Read Response.  The length is
626:                       // computed statically.
627:                       tx_hw_header.dlc = tx_can_data[ tx_msg_type ].data_len;
00196C  900A1E     MOV [W14+18], W4
00196E  B922E6     MUL.SU W4, #6, W4
001970  780284     MOV W4, W5
001972  294004     MOV #0x9400, W4
001974  428204     ADD W5, W4, W4
001976  784214     MOV.B [W4], W4
001978  62426F     AND.B W4, #0xF, W4
00197A  FB8204     ZE W4, W4
00197C  62026F     AND W4, #0xF, W4
00197E  90035E     MOV [W14+10], W6
001980  2FFF05     MOV #0xFFF0, W5
001982  630285     AND W6, W5, W5
001984  720205     IOR W4, W5, W4
001986  980754     MOV W4, [W14+10]
628:                   }
629:                   
630:                   // Copy the hardware header into the transmit buffer.
631:                   msg_buf[ 0 ] = tx_hw_header.data_u16[ 0 ];
001988  9002EE     MOV [W14+12], W5
00198A  900A2E     MOV [W14+20], W4
00198C  780A05     MOV W5, [W4]
632:                   msg_buf[ 1 ] = tx_hw_header.data_u16[ 1 ];  
00198E  900A2E     MOV [W14+20], W4
001990  E88204     INC2 W4, W4
001992  9002FE     MOV [W14+14], W5
001994  780A05     MOV W5, [W4]
633:                   msg_buf[ 2 ] = tx_hw_header.data_u16[ 2 ];
001996  900A2E     MOV [W14+20], W4
001998  420264     ADD W4, #0x4, W4
00199A  900A8E     MOV [W14+16], W5
00199C  780A05     MOV W5, [W4]
634:               }
00199E  FA8000     ULNK
0019A0  060000     RETURN
---  C:/Users/Jon Watson/Documents/GitHub/dspic33-servo-can-node.X/src/adc.c  ---------------------------
1:                 ////////////////////////////////////////////////////////////////////////////////
2:                 ///
3:                 /// @file   $FILE$
4:                 /// @author $AUTHOR$
5:                 /// @date   $DATE$
6:                 /// @brief  Source code file for defining hardware operation.   
7:                 ///
8:                 ////////////////////////////////////////////////////////////////////////////////
9:                 
10:                // *****************************************************************************
11:                // ************************** System Include Files *****************************
12:                // *****************************************************************************
13:                #include <xc.h>
14:                #include <stdbool.h>
15:                #include <stddef.h>
16:                #include <stdint.h>
17:                
18:                // *****************************************************************************
19:                // ************************** User Include Files *******************************
20:                // *****************************************************************************
21:                #include "adc.h"
22:                
23:                // *****************************************************************************
24:                // ************************** Defines ******************************************
25:                // *****************************************************************************
26:                
27:                // *****************************************************************************
28:                // ************************** Global Variable Definitions **********************
29:                // *****************************************************************************
30:                
31:                // *****************************************************************************
32:                // ************************** File-Scope Variable Definitions ******************
33:                // *****************************************************************************
34:                static uint16_t adc_val[ ADC_AIN_MAX ];
35:                
36:                // *****************************************************************************
37:                // ************************** Function Prototypes ******************************
38:                // *****************************************************************************
39:                
40:                // *****************************************************************************
41:                // ************************** Global Functions *********************************
42:                // *****************************************************************************
43:                void ADCInit ( void )
44:                {
001B9E  FA0000     LNK #0x0
45:                    AD1CON1bits.ADON    = 0;        // Turn ADC1 off - required for updating several ADC registers. Should already be 0 from reset value, but included for robustness.
001BA0  A9E321     BCLR 0x321, #7
46:                    AD1CON1bits.ADSIDL  = 0;        // N/A, set to Hw default.  Idle mode not entered.
001BA2  A9A321     BCLR 0x321, #5
47:                    AD1CON1bits.ADDMABM = 0;        // N/A, set to Hw default.  DMA not used.
001BA4  A98321     BCLR 0x321, #4
48:                    AD1CON1bits.AD12B   = 1;        // 12-bit, 1-channel (CH0) ADC operation.
001BA6  A84321     BSET 0x321, #2
49:                    AD1CON1bits.FORM    = 0b00;     // Unsigned integer output format (right-aligned)
001BA8  801904     MOV AD1CON1, W4
001BAA  A18004     BCLR W4, #8
001BAC  A19004     BCLR W4, #9
001BAE  881904     MOV W4, AD1CON1
50:                    AD1CON1bits.SSRC    = 0b111;    // Automatically start conversion when sampling is done.
001BB0  801904     MOV AD1CON1, W4
001BB2  A05004     BSET W4, #5
001BB4  A06004     BSET W4, #6
001BB6  A07004     BSET W4, #7
001BB8  881904     MOV W4, AD1CON1
51:                    AD1CON1bits.SSRCG   = 0;
001BBA  A98320     BCLR AD1CON1, #4
52:                    AD1CON1bits.SIMSAM  = 0;        // Sample CH0 inputs in sequence.
001BBC  A96320     BCLR AD1CON1, #3
53:                    AD1CON1bits.ASAM    = 0;        // Manual sampling - sampling begins when SAMP bit is set.
001BBE  A94320     BCLR AD1CON1, #2
54:                
55:                    AD1CON2bits.VCFG    = 0b000;    // N/A, set to Hw default. AVdd always used for high reference, AVss always used for low reference.
001BC0  801914     MOV AD1CON2, W4
001BC2  A1D004     BCLR W4, #13
001BC4  A1E004     BCLR W4, #14
001BC6  A1F004     BCLR W4, #15
001BC8  881914     MOV W4, AD1CON2
56:                    AD1CON2bits.CSCNA   = 0;        // Inputs are not scanned.
001BCA  A94323     BCLR 0x323, #2
57:                    AD1CON2bits.CHPS    = 0;        // N/A, set to Hw default.  Single channel (CH0) only possible in 12-bit mode.
001BCC  801914     MOV AD1CON2, W4
001BCE  A18004     BCLR W4, #8
001BD0  A19004     BCLR W4, #9
001BD2  881914     MOV W4, AD1CON2
58:                    AD1CON2bits.BUFS    = 0;        // N/A, set to Hw default.  Buffer fill status not valid since BUFM = 1.
001BD4  A9E322     BCLR AD1CON2, #7
59:                    AD1CON2bits.SMPI    = 0b0000;   // Do not generate interrupts after conversions.
001BD6  801915     MOV AD1CON2, W5
001BD8  2FF834     MOV #0xFF83, W4
001BDA  628204     AND W5, W4, W4
001BDC  881914     MOV W4, AD1CON2
60:                    AD1CON2bits.BUFM    = 0;        // Always start filling the buffer from the start address.
001BDE  A92322     BCLR AD1CON2, #1
61:                    AD1CON2bits.ALTS    = 0;        // Do not use Alternate Input Selection mode.
001BE0  A90322     BCLR AD1CON2, #0
62:                    
63:                    // Note: Per the DSCs electrical characteristic, the maximum Fad supported
64:                    // for 12-bit conversions is: ~8.5 MHz.
65:                    //
66:                    // Fad  =    Fcy / ( ADCS + 1 )
67:                    //      =  20MHz / (   99 + 1 )
68:                    //      = 200KHz
69:                    //
70:                    // Fsmp =    Fad / SAMC
71:                    //      = 200KHz /   20
72:                    //      =  10KHz
73:                    //
74:                    // (for 12-bit conversion):
75:                    // Fconv = Fad      / 14
76:                    //       = 200KHz   / 14
77:                    //       = 14.29KHz
78:                    //
79:                    AD1CON3bits.ADRC = 0;           // Clock derived from system clock.
001BE2  A9E325     BCLR 0x325, #7
80:                    AD1CON3bits.SAMC = 20;          // Set sampling frequency (Fsmp).
001BE4  801925     MOV AD1CON3, W5
001BE6  2E0FF4     MOV #0xE0FF, W4
001BE8  628284     AND W5, W4, W5
001BEA  214004     MOV #0x1400, W4
001BEC  720205     IOR W4, W5, W4
001BEE  881924     MOV W4, AD1CON3
81:                    AD1CON3bits.ADCS = 19;          // Set conversion frequency (Fconv).
001BF0  B3C134     MOV.B #0x13, W4
001BF2  784304     MOV.B W4, W6
001BF4  203245     MOV #0x324, W5
001BF6  784A86     MOV.B W6, [W5]
82:                    
83:                    AD1CON4bits.ADDMAEN = 0;        // Conversion results stored in ADC buffer, DMA not used.
001BF8  A90333     BCLR 0x333, #0
84:                    AD1CON4bits.DMABL   = 0;        // N/A, set to Hw default. DMA not used.
001BFA  801994     MOV AD1CON4, W4
001BFC  A10004     BCLR W4, #0
001BFE  A11004     BCLR W4, #1
001C00  A12004     BCLR W4, #2
001C02  881994     MOV W4, AD1CON4
85:                    
86:                    AD1CHS123bits.CH123SB2 = 0;     // N/A, set to Hw default. CH0 is only used channel.
001C04  A98327     BCLR 0x327, #4
87:                    AD1CHS123bits.CH123SB1 = 0;     // N/A, set to Hw default. CH0 is only used channel.
001C06  A96327     BCLR 0x327, #3
88:                    AD1CHS123bits.CH123NB1 = 0;     // N/A, set to Hw default. CH0 is only used channel.
001C08  A94327     BCLR 0x327, #2
89:                    AD1CHS123bits.CH123NB0 = 0;     // N/A, set to Hw default. CH0 is only used channel.
001C0A  A92327     BCLR 0x327, #1
90:                    AD1CHS123bits.CH123SB0 = 0;     // N/A, set to Hw default. CH0 is only used channel.
001C0C  A90327     BCLR 0x327, #0
91:                
92:                    AD1CHS0bits.CH0NB = 0;          // N/A, set to Hw default. MUX B not used.
001C0E  A9E329     BCLR 0x329, #7
93:                    AD1CHS0bits.CH0SB = 0;          // N/A, set to Hw default. MUX B not used.
001C10  801945     MOV AD1CHS0, W5
001C12  2C0FF4     MOV #0xC0FF, W4
001C14  628204     AND W5, W4, W4
001C16  881944     MOV W4, AD1CHS0
94:                    AD1CHS0bits.CH0NA = 0;          // Select Vref- for CH0 negative input.
001C18  A9E328     BCLR AD1CHS0, #7
95:                    
96:                    ANSELBbits.ANSB0 = 1;           // Configure PortB-Pin0 (RB0) for 'analog' operation.
001C1A  A80E22     BSET ANSELB, #0
97:                    ANSELBbits.ANSB1 = 1;           // Configure PortB-Pin1 (RB1) for 'analog' operation.
001C1C  A82E22     BSET ANSELB, #1
98:                    
99:                    TRISBbits.TRISB0 = 1;           // Configure PortB-Pin0 (RB0) for 'input' operation.
001C1E  A80E14     BSET TRISB, #0
100:                   TRISBbits.TRISB1 = 1;           // Configure PortB-Pin1 (RB1) for 'input' operation.
001C20  A82E14     BSET TRISB, #1
101:                   
102:                   // Note: The ADC hardware takes at most 20us (tDPU) to stabilize once the 
103:                   // module is enabled (i.e. bit ADON = 1).  The ADC result during this time
104:                   // is indeterminate and therefore should not be used.
105:                   //
106:                   AD1CON1bits.ADON = 1;           // Turn ADC1 on.
001C22  A8E321     BSET 0x321, #7
107:               }
001C24  FA8000     ULNK
001C26  060000     RETURN
108:               
109:               void ADCService ( void )
110:               {
001C28  FA0002     LNK #0x2
111:                   static const uint16_t ain_ch0sa_val[ ADC_AIN_MAX ] = 
112:                   {
113:                       2,
114:                       3,
115:                   };
116:                   
117:                   ADC_AIN_E ain_idx;
118:                   
119:                   // Perform conversion of all ADC signals.
120:                   for( ain_idx = (ADC_AIN_E) 0;
001C2A  EB0200     CLR W4
001C2C  780F04     MOV W4, [W14]
001C2E  37001D     BRA 0x1C6A
001C6A  78021E     MOV [W14], W4
001C6C  520FE1     SUB W4, #0x1, [W15]
001C6E  36FFE0     BRA LEU, 0x1C30
121:                        ain_idx < ADC_AIN_MAX;
122:                        ain_idx++ )
001C68  E80F1E     INC [W14], [W14]
123:                   {
124:                       // Select channel 0 positive input for the ADC signal.
125:                       AD1CHS0bits.CH0SA = ain_ch0sa_val[ ain_idx ];
001C30  78021E     MOV [W14], W4
001C32  420284     ADD W4, W4, W5
001C34  2948E4     MOV #0x948E, W4
001C36  428204     ADD W5, W4, W4
001C38  780214     MOV [W4], W4
001C3A  784204     MOV.B W4, W4
001C3C  B243F4     AND.B #0x3F, W4
001C3E  FB8284     ZE W4, W5
001C40  2003F4     MOV #0x3F, W4
001C42  628204     AND W5, W4, W4
001C44  801946     MOV AD1CHS0, W6
001C46  2FFC05     MOV #0xFFC0, W5
001C48  630285     AND W6, W5, W5
001C4A  720205     IOR W4, W5, W4
001C4C  881944     MOV W4, AD1CHS0
126:                       
127:                       // Clear identification of the conversion being done.
128:                       AD1CON1bits.DONE = 0;
001C4E  A90320     BCLR AD1CON1, #0
129:                       
130:                       // Start the sampling sequence (automatically following by conversion).
131:                       AD1CON1bits.SAMP = 1;
001C50  A82320     BSET AD1CON1, #1
132:                       
133:                       // Wait for the conversion to complete.
134:                       while( AD1CON1bits.DONE == 0 );
001C52  000000     NOP
001C54  801904     MOV AD1CON1, W4
001C56  620261     AND W4, #0x1, W4
001C58  520FE0     SUB W4, #0x0, [W15]
001C5A  32FFFC     BRA Z, 0x1C54
135:               
136:                       // Read the conversion into module data.
137:                       adc_val[ ain_idx ] = ADC1BUF0;
001C5C  801805     MOV ADC1BUF0, W5
001C5E  78021E     MOV [W14], W4
001C60  420304     ADD W4, W4, W6
001C62  2145C4     MOV #0x145C, W4
001C64  430204     ADD W6, W4, W4
001C66  780A05     MOV W5, [W4]
138:                   }
139:               }
001C70  FA8000     ULNK
001C72  060000     RETURN
140:               
141:               uint16_t ADCGet ( ADC_AIN_E adc_sel )
142:               {
001C74  FA0002     LNK #0x2
001C76  780F00     MOV W0, [W14]
143:                   return ( adc_val[ adc_sel ] );
001C78  78021E     MOV [W14], W4
001C7A  420284     ADD W4, W4, W5
001C7C  2145C4     MOV #0x145C, W4
001C7E  428204     ADD W5, W4, W4
001C80  780214     MOV [W4], W4
144:               }
001C82  780004     MOV W4, W0
001C84  FA8000     ULNK
001C86  060000     RETURN
145:               
146:               // *****************************************************************************
147:               // ************************** Static Functions *********************************
148:               // *****************************************************************************
